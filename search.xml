<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SALT Encrypt Best Practices]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FSALT_Encrypt_Best_Practices.html</url>
    <content type="text"><![CDATA[发现问题：这里展示一个简易的用户表： uid username password 1 zhangsan e10adc3949ba59abbe56e057f20f883e 2 lisi e10adc3949ba59abbe56e057f20f883e 3 wangwu 9bd5ee6fe55aaeb673025dbcb8f939c1 4 laoz f8a8d7997e870968f92748f3cc41cf90 我们发现 UID 1,2 对应的 password 是一样的，如果我是zhangsan，那岂不是同样我也知道lisi的密码明文是什么了？ 通过MD5密码破解网站，轻易的得到 e10adc3949ba59abbe56e057f20f883e 对应的明文是 123456 解决方案：我们知道，如果直接对密码进行散列，那么黑客可以对通过获得这个密码散列值，然后通过查散列值字典（例如MD5密码破解网站），得到某用户的密码。 加Salt可以一定程度上解决这一问题。所谓加Salt方法，就是加点“佐料”。其基本想法是这样的：当用户首次提供密码时（通常是注册时），由系统自动往这个密码里撒一些“佐料”，然后再散列。而当用户登录时，系统为用户提供的代码撒上同样的“佐料”，然后散列，再比较散列值，已确定密码是否正确。 这里的“佐料”被称作“Salt值”也称“盐值”，这个加“佐料”的行为叫做“加盐”，这个值是由系统随机生成的，并且只有系统知道。这样，即便两个用户使用了同一个密码，由于系统为它们生成的salt值不同，他们的散列值也是不同的。即便黑客可以通过自己的密码和自己生成的散列值来找具有特定密码的用户，但这个几率太小了（密码和salt值都得和黑客使用的一样才行）。 有时候，为了减轻开发压力，程序员会统一使用一个salt值（储存在某个地方），而不是每个用户都生成私有的salt值。但是这样的话还是解决不了上述我们发现同密文反推明文的问题。 算法实现123salt=random()//获取一个随机的字符串src=123456password=md5(salt+src) 下面详细介绍一下加Salt散列的过程。介绍之前先强调一点，前面说过，验证密码时要使用和最初散列密码时使用“相同的”佐料。所以Salt值是要存放在数据库里的。 用户注册时用户输入【账号】和【密码】（以及其他用户信息）；系统为用户生成【Salt值】；系统将【Salt值】和【用户密码】连接到一起；对连接后的值进行散列，得到【Hash值】；将【Hash值1】和【Salt值】分别放到数据库中。 用户登录时用户输入【账号】和【密码】；系统通过用户名找到与之对应的【Hash值】和【Salt值】；系统将【Salt值】和【用户输入的密码】连接到一起；对连接后的值进行散列，得到【Hash值2】（注意是即时运算出来的值）；比较【Hash值1】和【Hash值2】是否相等，相等则表示密码正确，否则表示密码错误。 增强版用户表设计 uid username password salt 1 zhangsan ad4b3e001f961ef2792ccaae9d05c873 eyJ1a 2 lisi f73f9c73c5e6e6059c9948a78ee81957 WQiOj 3 wangwu 9bd5ee6fe55aaeb673025dbcb8f939c1 EwMDE 4 laoz f8a8d7997e870968f92748f3cc41cf90 U0MDk 即便 zhangsan，lisi 的密码明文都是 123456，由于他们的salt不同则最终的password密文也不同，由于salt增加的密码的复杂度，被破解的难度也更大。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>openapi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Access Token & Refresh Token]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FAccessToken%26RefreshToken.html</url>
    <content type="text"><![CDATA[设计需求 统计在线列表，可以随时的踢下线，让客户端缓存的token失效 30天内无需重新登录，默认可无限期延续 Token生成方案 JWT（JSON WEB TOKEN）的构成第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签名（signature确保数据的完整性).JWT token = header.payload.signature由于JWT是无状态的，也未能实现我们上述的需求，所以不得不放弃了JWT的方案，但是其有关token的加密算法还是值得参考的。 access_token生成方案12345678payload = urlencode(base64(&#123;uid,ts&#125;))salt=TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ //盐值signature = HMACSHA256(payload,salt);access_token = payload.signatureredis_key = access_token:uid:&#123;access_token&#125;//uid 是从token中payload解析出来的redis_value = userinforedis_ttl = 2hr refresh_token生成方案12345678payload = urlencode(base64(&#123;uid,ts&#125;))salt=TJVA95Or11.0cBab30RMHrHDcEfxjoYZgeFONFh7HgQ //盐值signature = HMACSHA256(payload,salt);refresh_token = payload.signature;redis_key = refresh_token:uid:&#123;refresh_token&#125;//uid 是从token中payload解析出来的redis_value = access_tokenredis_ttl = 30days 算法实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import org.apache.commons.codec.binary.Base64;import com.fanfq.util.commons.encrypt.HMACSHA256;System.out.println("\n#####token生成算法"); Long uid = 10010l;Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); map.put("uid", uid); map.put("ts", System.currentTimeMillis()); String str = JSONObject.toJSONString(map); String base64 = Base64.encodeBase64String(str.getBytes()); String payload = null; try &#123; payload = URLEncoder.encode(base64,"UTF-8");&#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace();&#125;String salt = "TJVA95Or11.0cBab30RMHrHDcEfxjoYZgeFONFh7HgQ";String signature = HMACSHA256.encode(payload,salt);String token = payload+"."+signature;System.out.println("payload:"+payload);System.out.println("signature:"+signature);System.out.println("token:"+token);System.out.println("redis key: token:"+uid+":"+token);System.out.println("\n#####token校验算法");System.out.println("1.签名校验");System.out.println("token:"+token);String payload_ = token.split("\\.")[0];String signature_ = token.split("\\.")[1];System.out.println("payload密文:"+payload_);System.out.println("signature签名:"+signature_);boolean check = HMACSHA256.encode(payload_,salt).equals(signature_);System.out.println("签名校验："+check);System.out.println("\n2.时间戳校验");String urldecode = null;try &#123; urldecode = URLDecoder.decode(payload_, "UTF-8");&#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace();&#125;String jsondecode = new String(Base64.decodeBase64(urldecode));System.out.println("payload解密："+jsondecode);JSONObject jsobj = JSONObject.parseObject(jsondecode);Long ts = jsobj.getLong("ts");System.out.println(System.currentTimeMillis() - ts +" ms");if(System.currentTimeMillis() - ts &gt; 1000*60*60*2) &#123; System.out.println("超过2小时");&#125;else &#123; System.out.println("有效期内，开始进行redis查询");&#125; token生成算法12345明文：&#123;&quot;uid&quot;:10010,&quot;ts&quot;:1540912751948&#125;payload:eyJ1aWQiOjEwMDEwLCJ0cyI6MTU0MDkxMjc1MTk0OH0%3Dsignature:0ba40cff2bda8fab9ae61893b43c198e3022a1e8f058ac8054417241d3129d1ftoken:eyJ1aWQiOjEwMDEwLCJ0cyI6MTU0MDkxMjc1MTk0OH0%3D.0ba40cff2bda8fab9ae61893b43c198e3022a1e8f058ac8054417241d3129d1fredis key: token:10010:eyJ1aWQiOjEwMDEwLCJ0cyI6MTU0MDkxMjc1MTk0OH0%3D.0ba40cff2bda8fab9ae61893b43c198e3022a1e8f058ac8054417241d3129d1f token校验算法 签名校验 1234token:eyJ1aWQiOjEwMDEwLCJ0cyI6MTU0MDkxMjc1MTk0OH0%3D.0ba40cff2bda8fab9ae61893b43c198e3022a1e8f058ac8054417241d3129d1fpayload密文:eyJ1aWQiOjEwMDEwLCJ0cyI6MTU0MDkxMjc1MTk0OH0%3Dsignature签名:0ba40cff2bda8fab9ae61893b43c198e3022a1e8f058ac8054417241d3129d1f签名校验：true 时间戳校验 123payload解密：&#123;&quot;uid&quot;:10010,&quot;ts&quot;:1540912751948&#125;690 ms有效期内，开始进行redis查询 注意：这个也是我经过思考后最终确认下来的token生成算法，也许你也发现既然redis持久化了就直接查库即可，无需搞的这么复杂的算法。实际上我是这样考虑的，因为大量的api请求都会带token参数导致每次请求都会查询库，固然redis的强大的性能足以支持，但还是为了效率过滤一些没有必要的io资源。 得到请求的时候首先验证signature是否匹配，防止篡改 再从payload中获取ts以判断时间戳是否失效，access_token 2hr, refresh_token 30days. 前两者校验完成，则请求一次redis io做最终的判断。当然排除临时被提下线的情况下，大部分情况下这里都是通过的。 redis key 的设计，其中的uid设计主要是为了后期统计使用，如： 123456789101112keys （refresh_token:uid:*）获取当前终端连接数，Set&lt;String&gt; setz = jedis.keys(&quot;access_token:*&quot;);System.out.println(&quot;access_token:* key 的数目:&quot;+setz.size());获取当前在线用户数（根据uid排重） Set&lt;String&gt; setzz = new HashSet&lt;String&gt;();for(String str:setz) &#123; setzz.add(str.split(&quot;:&quot;)[1]);&#125;System.out.println(&quot;key uid 去重：&quot;+setzz.size()); redis ttl 就不用不多说了，access_token 2hr, refresh_token 30days. redis value：whatever anythings Redis 有状态缓存access_token key ttl value access_token:10024:ak_1 2hr username:zhangsan,uid:10024 access_token:10025:ak_2 2hr username:lisi,uid:10025 refresh_token key ttl value refresh_token:10024:rk_1 30days access_token:10024:ak_1 refresh_token:10025:rk_2 30days access_token:10025:ak_2 拓扑结构 用户授权获取token请求方法：https://apihost/oauth2/access_token?username=zhangsan&amp;password=123456 正确的返回：12345678910&#123; "code":200, "msg":"ok", "data":&#123; "access_token":"ak_1", "uid":10024, "refresh_token":"rk_1", "expires_in":7200 &#125;&#125; 参数 说明 access_token 接口调用凭证 refresh_token 用户刷新access_token uid 授权用户唯一标识 expires_in access_token接口调用凭证超时时间，单位（秒） 错误返回样例：{&quot;code&quot;:400,&quot;msg&quot;:&quot;bad request&quot;} 刷新access_token有效期access_token是调用授权关系接口的调用凭证，由于access_token有效期（目前为2个小时）较短，当access_token超时后，可以使用refresh_token进行刷新，用refresh_token仅能使用一次，使用一次后，将被废弃。也就是说refresh_token 更新 access_token 的时候 refresh_token 也会跟着被更新 通过用refresh_token机制可以确保活跃用户长期不用登录授权。 refresh_token拥有较长的有效期（30天），当refresh_token失效的后，需要用户重新授权。也就说第一次登录与第二次登录时长间隔30天以上则需要用户重新授权登录。 请求方法：https://apihost/oauth2/refresh_token?uid=UID&amp;refresh_token=REFRESH_TOKEN 正确的返回：12345678910&#123; "code":200, "msg":"ok", "data":&#123; "access_token":"ak_1", "uid":10024, "refresh_token":"rk_1", "expires_in":7200 &#125;&#125; 参数 说明 access_token 接口调用凭证 refresh_token 用户刷新access_token uid 授权用户唯一标识 expires_in access_token接口调用凭证超时时间，单位（秒） 错误返回样例：{&quot;code&quot;:400,&quot;msg&quot;:&quot;invalid refresh_token&quot;} 通过access_token调用接口获取access_token后，进行接口调用，有以下前提：access_token有效且未超时；如果access_token失效，则通过refresh_token重新同步。若refresh_token也失效了则需要用户重新授权登录。 Eg.通过UID获取用户基本信息请求方法https://apihost/user?access_token=ak_1&amp;uid=10024 正确的返回123456789&#123; "code":200, "msg":"ok", "data":&#123; "username":"zhangsan", "age":28, "address":"xx路xx号" &#125;&#125; 错误返回样例：{&quot;code&quot;:400,&quot;msg&quot;:&quot;invalid access_token&quot;} 注意事项RISK CONTROL access_token 为用户授权客户端发起接口调用的凭证（相当于用户登录态），存储在客户端，可能出现恶意获取access_token 后导致的用户数据泄漏、用户微信相关接口功能被恶意发起等行为； refresh_token 为用户授权客户端应用的长效凭证，仅用于刷新access_token，但泄漏后相当于access_token 泄漏，风险同上。 单点/多点登录。介于我们当前的设计不考虑单点登录的问题，也就是说同一个账号在不同的客户端都可以同时登录，并且生成不同的token以供使用每个客户端程序维护自己的一套token即可。倘若要实现单点登录则在用户授权的时候做排重判断，如果已在其他重点登录则清空该重点的token，并且为当前链接生成新token对即可。具体情况shi 用户信息跟新，针对我们当前的授权方式一旦用户修改的密码，则要清空该用户所有终端的token，让其重新授权。这也是为什么要设计这套有状态的token机制主要原因]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>openapi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Internal APIs encrypt Method V1.0]]></title>
    <url>%2FInternalAPIs_encrypt_Method_V1.0.html</url>
    <content type="text"><![CDATA[简单对称密码加密解密2018/10/19 我们发现大量的非法不带参数的Http请求访问我们的 apihost, 请求日志文件如下所示。 12345183.223.44.221 - - [19/Oct/2018:16:47:32 +0800] &quot;POST /api_interface? HTTP/1.1&quot; 200 174 &quot;-&quot; &quot;okhttp/3.10.0&quot;请求者IP：183.223.44.221 请求接口：api_interface请求方式：POST请求者UA：okhttp/3.10.0 问题引申：既然是非法请求，为什么黑客没有带参数的请求？实际上这是一个很好的问题，如果接口没有做任何安全处理的话，黑客通过抓包很容易拿到请求参数规则，然后通过模拟请求达到目的。一旦接口做过”特殊工艺”处理了，黑客即将无处是从了。最终他们的心态都是从破解到放弃这样一个过程。 正确的请求姿势：实际上我们的设计接口的时候会有一个统一的接收参数 params 用来接收我们的数据，正确的请求如下： 12345183.223.44.221 - - [19/Oct/2018:16:47:32 +0800] &quot;POST /api_interface?params=sM4AOVdWfPE4DxkXGEs8VFmEsZRgy58UYDPD7PjVYQXx1GEFrbjXMo11fb9x6ppwuaAeXV3n2DtoW4lG22nM0g HTTP/1.1&quot; 200 174 &quot;-&quot; &quot;okhttp/3.10.0&quot;请求者IP：183.223.44.221 请求接口：api_interface?params=sM4AOVdWfPE4DxkXGEs8VFmEsZRgy58UYDPD7PjVYQXx1GEFrbjXMo11fb9x6ppwuaAeXV3n2DtoW4lG22nM0g请求方式：POST请求者UA：okhttp/3.10.0 拓扑结构：什么请求者IP,请求方式，UA都不是重点。重点在于我们的接口都会有一个params的参数，而这个参数的本身是通过加密算法形成的，即使黑客捕获到这串没有意义的密文也头疼。因为我们和客户端程序有规定所有请求的参数必须要用公钥加密后再通过特点的算法传递，同时服务器端返回的数据也是通过这套算法加密后传输。拓扑结构如下图。 为什么要数据加密？安全，安全，安全。 解决方案：现在通过一个示例完整的描述一下我们的接口设计中加密解密过程。 公钥上文中说道，我们同时约定了一套公钥给服务器端与客户端，为了配合下面的算法使用所以我们采用Int 类型的数字。现在定义为 KEY = 110; 为了确保安全性这个KEY只有内部知道。 算法 XOR （with KEY） BASE64 (encode/decode) URLEncode/URLDecode Eg.客户端 zhangsan 执行登录请求将要发送的数据:{username:zhangsan,password:123456,action:login} 123456789Map&lt;String,String&gt; reqMap = new HashMap&lt;String,String&gt;();int key = 110;//客户端与服务器端共同约定的公钥@Beforepublic void be() &#123; reqMap.put("username", "zhangsan"); reqMap.put("password", "123456"); reqMap.put("action", "login");&#125; 加密算法 （java实现）12345678910111213//1.xorbyte[] byteArry = reqMap.toString().getBytes();for (int i = 0; i &lt; byteArry.length; i++) &#123; byteArry[i] = (byte) (byteArry[i] ^ key);&#125;//2.base64.ecodeString encode = new BASE64Encoder().encode(byteArry);//3.url.encodeString dist = URLEncoder.encode(encode, "UTF-8");System.out.println("params="+dist); 输出的params为:params=FR4PHR0ZARwKU19cXVpbWEJODw0aBwEAUwIBCQcAQk4bHQscAA8DC1MUBg8ACR0PABM%3D 解密算法 （java实现）1234567891011121314String params = "FR4PHR0ZARwKU19cXVpbWEJODw0aBwEAUwIBCQcAQk4bHQscAA8DC1MUBg8ACR0PABM%3D";//1.url.decodeString decode = URLDecoder.decode(params, "UTF-8");//2.base64.decodebyte[] byteArry = new BASE64Decoder().decodeBuffer(decode);//3.xorfor (int i = 0; i &lt; byteArry.length; i++) &#123; byteArry[i] = (byte) (byteArry[i] ^ key);&#125;System.out.println("dist:"+new String(byteArry)); 输出的dist为：dist={username:zhangsan,password:123456,action:login} 对称加密优缺点对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。适用于简单的报文加密，同时也使用用大报文加密。对称加密算法的缺点是在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。 常用的对称密钥算法加密和解密都使用同一把秘钥，这种加密方法称为对称加密，也称为单密钥加密。简单理解为：加密解密都是同一把钥匙。AES、DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK 等。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>openapi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Open APIs encrypt Method V1.1]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FOpenAPIs_encrypt_Method_V1.1.html</url>
    <content type="text"><![CDATA[非对称密码加密解密&amp;签名机制&amp;重放攻击《Internal APIs encrypt Method V1.0》 文章中已经描述了我们正在线上产品所用的加密算法，实际上他不仅仅是解决防参数篡改的问题，同时也解决了数据隐私保护的问题。即便如此这套算法还是有漏洞的，也是做所以定义为 Internal APIs的主要原因了，由于只提供给内部使用所以安全性暂且得到保障，一旦提供给外部使用则全盘”露馅”了,这也是我为什么要编辑此篇《Open APIs encrypt Method V1.1》文章了。 其中最为致命的问题是要在客户端代码中公开自己的密钥以及算法，一旦黑客从客户端程序中反编译源码，这样就会导致整个加密体系的崩盘，而且连补救的措施都没有。 同时第二个比较严重的问题就是黑客从放攻击的问题，黑客在抓取到包体后，直接再次提交请求导致服务器端不断受到重复请求。 所以基于以上两点，我们了解到《Internal APIs encrypt Method V1.0》所存在的问题如下表所示 问题描述 安全性 解决方案 脱敏（数据隐私保护） 安全 完整性 （防参数篡改） 安全 重放攻击 （重复提交） 未解决 timestamp + nonce 对称密钥 不够安全 非对称密钥 签名机制：所以本文重点就是要解决 重放攻击 (重复提交) &amp; 密钥安全 这两个问题。在此之前再介绍一种常用的解决数据传输过程中确保完整性 （防参数篡改）的解决方案，过程如下： 客户端使用约定好的秘钥对传输参数进行加密，得到签名值signature，并且将签名值也放入请求参数中，发送请求给服务端 服务端接收客户端的请求，然后使用约定好的秘钥对请求的参数（除了signature以外）再次进行签名，得到签名值autograph。 服务端对比signature和autograph的值，如果对比一致，认定为合法请求。如果对比不一致，说明参数被篡改，认定为非法请求。 Eg.客户端 zhangsan 执行登录请求将要发送的数据：apihost?action=login&amp;username=zhangsan&amp;password=123456&amp;sign= 签名算法：(java 实现)12345678910111213141516171819//1.对除sign外的所有参数按字典排序 对所有待签名参数按照字段名的 ASCII码从小到大排序（字典序）后 String[] arr = new String[] &#123; "username=zhangsan","password=123456", "action=login"&#125;;Arrays.sort(arr); //2.将排序后的结果拼接成一个字符串（即key1=value1&amp;key2=value2…）String content = arr[0].concat("&amp;"+arr[1]).concat("&amp;"+arr[2]);//3、将字符串进行sha1加密得到sign值MessageDigest md = null;String sign = null; try &#123; md = MessageDigest.getInstance("SHA-1"); byte[] digest = md.digest(content.toString().getBytes()); sign = StrUtil.byteToStr(digest);&#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace();&#125;System.out.println("sign="+sign); 输出的sign为:sign=ebb36366bd9d8656e2327ca913a4f854f35a0e95 最终请求服务器的数据为：apihost?action=login&amp;username=zhangsan&amp;password=123456&amp;sign=ebb36366bd9d8656e2327ca913a4f854f35a0e95 当服务器拿到数据后再进行同样的算法然后再匹配sign值是否一致，如果对比一致，认定为合法请求。如果对比不一致，说明参数被篡改，认定为非法请求。 注意事项： 参数排序很重要，不同的排序会导致签名值不一致。所以要事先规定好排序算法。 sign算法也要事先规定好，示例中是一个简单的算法并没有使用到密钥。实际过程中可能更加复杂签名的秘钥我们可以使用很多方案，可以采用对称加密或者非对称加密。 因为黑客不知道签名的秘钥，也不知道签名的算法，所以即使截取到请求数据，对请求参数进行篡改，但是却无法对参数进行签名，无法得到修改后参数的签名值signature。 示例中并没有解决数据脱敏的问题，应用过程中可以根据实际情况再进行脱敏算法。 防止重放攻击基于timestamp的方案每次HTTP请求，都需要加上timestamp参数，然后把timestamp和其他参数一起进行数字签名。因为一次正常的HTTP请求，从发出到达服务器一般都不会超过60s，所以服务器收到HTTP请求之后，首先判断时间戳参数与当前时间相比较，是否超过了60s，如果超过了则认为是非法的请求。 一般情况下，黑客从抓包重放请求耗时远远超过了60s，所以此时请求中的timestamp参数已经失效了。 如果黑客修改timestamp参数为当前的时间戳，则signature参数对应的数字签名就会失效，因为黑客不知道签名秘钥，没有办法生成新的数字签名。 但这种方式的漏洞也是显而易见的，如果在60s之后进行重放攻击，那就没办法了，所以这种方式不能保证请求仅一次有效。 基于nonce的方案nonce的意思是仅一次有效的随机字符串，要求每次请求时，该参数要保证不同，所以该参数一般与时间戳有关，我们这里为了方便起见，直接使用时间戳的16进制，实际使用时可以加上客户端的ip地址，mac地址等信息做个哈希之后，作为nonce参数。 我们将每次请求的nonce参数存储到一个“集合”中，可以json格式存储到数据库或缓存中。 每次处理HTTP请求时，首先判断该请求的nonce参数是否在该“集合”中，如果存在则认为是非法请求。 nonce参数在首次请求时，已经被存储到了服务器上的“集合”中，再次发送请求会被识别并拒绝。 nonce参数作为数字签名的一部分，是无法篡改的，因为黑客不清楚token，所以不能生成新的sign。 这种方式也有很大的问题，那就是存储nonce参数的“集合”会越来越大，验证nonce是否存在“集合”中的耗时会越来越长。我们不能让nonce“集合”无限大，所以需要定期清理该“集合”，但是一旦该“集合”被清理，我们就无法验证被清理了的nonce参数了。也就是说，假设该“集合”平均1天清理一次的话，我们抓取到的该url，虽然当时无法进行重放攻击，但是我们还是可以每隔一天进行一次重放攻击的。而且存储24小时内，所有请求的“nonce”参数，也是一笔不小的开销。 基于timestamp和nonce的方案nonce的一次性可以解决timestamp参数60s的问题，timestamp可以解决nonce参数“集合”越来越大的问题。防止重放攻击一般和防止请求参数被串改一起做，请求的Headers数据如下图所示。 我们在timestamp方案的基础上，加上nonce参数，因为timstamp参数对于超过60s的请求，都认为非法请求，所以我们只需要存储60s的nonce参数的“集合”即可。 HTTP请求头，参数说明：由于每次数据请求都要带上这几个参数，所以直接将这几个参数设置在请求头中，从而简化body长度；当然也可以在去请求参数中拼凑视具体情况而定。 参数名 参数说明 备注 token 用户令牌，用于认证用户身份 稍微长一点的文本 sign 签名，用于监测请求数据的完整性 中等文本 timestamp 请求时间戳 根据的约定的保留毫秒或者精度到秒 nonce 请求随机字符串: MD5(时间戳+随机字符) 单位时间内产生不重复字符就好 有关token的详细说明，请查看《Access Token &amp; Refresh Token 机制》这篇文章 服务器端校验：服务器端的校验配置通常会放在Filter / Interceptor 中,作为全局的管理。nonce参数通常会存在redis中，并且设置TTL过期时间。123456789101112131415161718192021222324252627282930313233343536373839404142String token = request.getHeader("token");String timestamp = request.getHeader("timestamp");String nonce = request.getHeader("nonce");String sign = request.getHeader("sign");//时间限制配置 sint timeLimit = 60;//请求头参数非空验证if (StringUtils.isEmpty(token) || StringUtils.isEmpty(timestamp) || StringUtils.isEmpty(nonce) || StringUtils.isEmpty(sign)) &#123; ctx.setResponseBody(JSON.toJSONString(new Result("-1", "请求头参数不正确"))); return null;&#125;//请求时间和现在时间对比验证，发起请求时间和服务器时间不能超过timeLimit秒if (StringUtils.timeDiffSeconds(new Date(), timestamp) &gt; timeLimit) &#123; ctx.setResponseBody(JSON.toJSONString(new Result("-1", "请求发起时间超过服务器限制"))); return null;&#125;//验证用户信息UserInfo userInfo = UserInfoUtil.getInfoByToken(token);if (userInfo == null) &#123; ctx.setResponseBody(JSON.toJSONString(new Result("-1", "错误的token信息"))); return null;&#125;//验证相同noce的请求是否已经存在，存在表示为重复请求if (NoceUtil.exsit(userInfo, nonce)) &#123; ctx.setResponseBody(JSON.toJSONString(new Result("-1", "重复的请求"))); return null;&#125; else &#123; //如果noce没有在缓存中，则需要加入，并设置过期时间为timeLimit秒 NoceUtil.addNoce(userInfo, nonce, timeLimit);&#125;//服务器生成签名与header中签名对比String serverSign = SignUtil.getSign(userinfo, token, timestamp, nonce, request);if (!serverSign.equals(sign)) &#123; ctx.setResponseBody(JSON.toJSONString(new Result("-1", "错误的签名信息"))); return null;&#125; 非对称密钥拓扑结构与对称密钥不同，非对称密钥要有一组密钥分别是公钥和私钥，通常情况下公钥加密，私钥解密。公钥可以发布给任意的客户端程序，服务器端则通过私钥解密。以下是非对称密钥的拓扑结构。 如上图所以，发送者用接收方公开出来的公钥PK进行加密。接受方在收到密文后，再用与公钥对应的私钥SK进行解密。同样，密文即便被截获，但是由于截获者只有公钥，没有私钥，他不能进行解密 非对称加密优缺点非对称加密的突出优点是用于解密的密钥（也就是私钥）永远不需要传递给对方。但是，它的缺点也很突出：非对称加密算法复杂，导致加解密速度慢，故只适合小量数据的场合。而对称加密加解密效率高，系统开销小，适合进行大数据量的加解密。由于文件一般比较大，这个特性决定了适合它的加密方式最好是对称加密。 Eg.RSA对称密钥算法（java实现）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232package com.fanfq.util.commons.encrypt.rsa;import org.apache.commons.codec.binary.Base64;import javax.crypto.Cipher;import java.security.*;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;import java.util.HashMap;import java.util.Map;/**&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.11&lt;/version&gt;&lt;/dependency&gt;https://www.jianshu.com/p/ff8281f034f4 * @author fred * */public class RSAUtil2 &#123; public static final String KEY_ALGORITHM = "RSA"; public static final String SIGNATURE_ALGORITHM = "MD5withRSA"; private static final String PUBLIC_KEY = "RSAPublicKey"; private static final String PRIVATE_KEY = "RSAPrivateKey"; public static byte[] decryptBASE64(String key) &#123; return Base64.decodeBase64(key); &#125; public static String encryptBASE64(byte[] bytes) &#123; return Base64.encodeBase64String(bytes); &#125; /** * 用私钥对信息生成数字签名 * * @param data 加密数据 * @param privateKey 私钥 * @return * @throws Exception */ public static String sign(String data, String privateKey) throws Exception &#123; // 解密由base64编码的私钥 byte[] keyBytes = decryptBASE64(privateKey); // 构造PKCS8EncodedKeySpec对象 PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); // KEY_ALGORITHM 指定的加密算法 KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); // 取私钥匙对象 PrivateKey priKey = keyFactory.generatePrivate(pkcs8KeySpec); // 用私钥对信息生成数字签名 Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM); signature.initSign(priKey); signature.update(data.getBytes()); return encryptBASE64(signature.sign()); &#125; /** * 校验数字签名 * * @param data 加密数据 * @param publicKey 公钥 * @param sign 数字签名 * @return 校验成功返回true 失败返回false * @throws Exception */ public static boolean verify(String data, String publicKey, String sign) throws Exception &#123; // 解密由base64编码的公钥 byte[] keyBytes = decryptBASE64(publicKey); // 构造X509EncodedKeySpec对象 X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes); // KEY_ALGORITHM 指定的加密算法 KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); // 取公钥匙对象 PublicKey pubKey = keyFactory.generatePublic(keySpec); Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM); signature.initVerify(pubKey); signature.update(data.getBytes()); // 验证签名是否正常 return signature.verify(decryptBASE64(sign)); &#125; public static byte[] decryptByPrivateKey(byte[] data, String key) throws Exception&#123; // 对密钥解密 byte[] keyBytes = decryptBASE64(key); // 取得私钥 PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateKey = keyFactory.generatePrivate(pkcs8KeySpec); // 对数据解密 Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, privateKey); return cipher.doFinal(data); &#125; /** * 解密&lt;br&gt; * 用私钥解密 * * @param data * @param key * @return * @throws Exception */ public static byte[] decryptByPrivateKey(String data, String key) throws Exception &#123; return decryptByPrivateKey(decryptBASE64(data),key); &#125; /** * 解密&lt;br&gt; * 用公钥解密 * * @param data * @param key * @return * @throws Exception */ public static String decryptByPublicKey(String data, String key) throws Exception &#123; byte[] datas = decryptBASE64(data); // 对密钥解密 byte[] keyBytes = decryptBASE64(key); // 取得公钥 X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicKey = keyFactory.generatePublic(x509KeySpec); // 对数据解密 Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, publicKey); return new String(cipher.doFinal(datas)); &#125; /** * 加密&lt;br&gt; * 用公钥加密 * * @param data * @param key * @return * @throws Exception */ public static String encryptByPublicKey(String data, String key) throws Exception &#123; // 对公钥解密 byte[] keyBytes = decryptBASE64(key); // 取得公钥 X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicKey = keyFactory.generatePublic(x509KeySpec); // 对数据加密 Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, publicKey); return encryptBASE64(cipher.doFinal(data.getBytes())); &#125; /** * 加密&lt;br&gt; * 用私钥加密 * * @param data * @param key * @return * @throws Exception */ public static String encryptByPrivateKey(String data, String key) throws Exception &#123; // 对密钥解密 byte[] keyBytes = decryptBASE64(key); // 取得私钥 PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateKey = keyFactory.generatePrivate(pkcs8KeySpec); // 对数据加密 Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, privateKey); return encryptBASE64(cipher.doFinal(data.getBytes())); &#125; /** * 取得私钥 * * @param keyMap * @return * @throws Exception */ public static String getPrivateKey(Map&lt;String, Key&gt; keyMap) throws Exception &#123; Key key = (Key) keyMap.get(PRIVATE_KEY); return encryptBASE64(key.getEncoded()); &#125; /** * 取得公钥 * * @param keyMap * @return * @throws Exception */ public static String getPublicKey(Map&lt;String, Key&gt; keyMap) throws Exception &#123; Key key = keyMap.get(PUBLIC_KEY); return encryptBASE64(key.getEncoded()); &#125; /** * 初始化密钥 * * @return * @throws Exception */ public static Map&lt;String, Key&gt; initKey(int length) throws Exception &#123; KeyPairGenerator keyPairGen = KeyPairGenerator .getInstance(KEY_ALGORITHM); if(length != 2048) length = 1024; keyPairGen.initialize(length); KeyPair keyPair = keyPairGen.generateKeyPair(); Map&lt;String, Key&gt; keyMap = new HashMap(2); keyMap.put(PUBLIC_KEY, keyPair.getPublic());// 公钥 keyMap.put(PRIVATE_KEY, keyPair.getPrivate());// 私钥 return keyMap; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.fanfq.util.commons.encrypt.rsa;import java.io.FileOutputStream;import java.io.ObjectOutputStream;import java.security.Key;import java.util.Map;public class RSAUtil2Test &#123; private String publicKey; private String privateKey; public void setUp() throws Exception &#123; Map&lt;String, Key&gt; keyMap = RSAUtil2.initKey(2048); publicKey = RSAUtil2.getPublicKey(keyMap); privateKey = RSAUtil2.getPrivateKey(keyMap); System.out.println("公钥:" + publicKey.length()); System.out.println(publicKey); System.out.println("私钥:" + privateKey.length()); System.out.println(privateKey); ObjectOutputStream oos1 = null; ObjectOutputStream oos2 = null; try &#123; /** 用对象流将生成的密钥写入文件 */ oos1 = new ObjectOutputStream(new FileOutputStream("RSA_PUBLIC_KEY")); oos2 = new ObjectOutputStream(new FileOutputStream("RSA_PRIVATE_KEY")); oos1.writeObject(publicKey); oos2.writeObject(privateKey); &#125; catch (Exception e) &#123; throw e; &#125; finally &#123; /** 清空缓存，关闭文件输出流 */ oos1.close(); oos2.close(); &#125; &#125; public void test() throws Exception &#123; System.out.println("\n-------------"); System.out.println("公钥加密——私钥解密"); String inputStr = "dounine"; String encodedData = RSAUtil2.encryptByPublicKey(inputStr, publicKey); byte[] decodedData = RSAUtil2.decryptByPrivateKey(encodedData, privateKey); String outputStr = new String(decodedData); System.out.println("加密前: " + inputStr); System.out.println("公钥加密后: " + encodedData); System.out.println("私钥解密后: " + outputStr); &#125; public void testSign() throws Exception &#123; System.out.println("\n-------------"); System.out.println("私钥加密——公钥解密"); String inputStr = "dounine"; String encodedData = RSAUtil2.encryptByPrivateKey(inputStr, privateKey); String decodedData = RSAUtil2.decryptByPublicKey(encodedData, publicKey); System.out.println("加密前: " + inputStr); System.out.println("私钥加密后: " + encodedData); System.out.println("公钥解密后: " + decodedData); System.out.println("\n私钥签名——公钥验证签名"); // 产生签名 String sign = RSAUtil2.sign("123", privateKey); System.out.println("私钥签名:("+sign.length()+")" + sign); // 验证签名 boolean status = RSAUtil2.verify(encodedData, publicKey, sign); System.out.println("公钥验证签名:" + status); &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub RSAUtil2Test rsa = new RSAUtil2Test(); try &#123; rsa.setUp(); rsa.test(); rsa.testSign(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>openapi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-wolrd.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! 文本 This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start uid username password 1 zhangsan ad4b3e001f961ef2792ccaae9d05c873 2 lisi f73f9c73c5e6e6059c9948a78ee81957 3 wangwu 9bd5ee6fe55aaeb673025dbcb8f939c1 4 laoz f8a8d7997e870968f92748f3cc41cf90 blah blah blah Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 1 一个普通标题 一个普通标题 一个普通标题 短文本 中等文本 稍微长一点的文本 稍微长一点的文本 短文本 中等文本 https://theme-next.iissnan.com/tag-plugins.html#center-blockquote-usage]]></content>
      <categories>
        <category>Testing</category>
      </categories>
  </entry>
</search>
