<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fred&#39;s Blog</title>
  
  <subtitle>Quick notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.fanfq.com/"/>
  <updated>2018-11-07T01:23:19.081Z</updated>
  <id>http://blog.fanfq.com/</id>
  
  <author>
    <name>Fred Fan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SALT Encrypt Best Practices</title>
    <link href="http://blog.fanfq.com/%E7%AE%97%E6%B3%95/SALT_Encrypt_Best_Practices.html"/>
    <id>http://blog.fanfq.com/算法/SALT_Encrypt_Best_Practices.html</id>
    <published>2018-10-31T01:14:33.000Z</published>
    <updated>2018-11-07T01:23:19.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="发现问题："><a href="#发现问题：" class="headerlink" title="发现问题："></a>发现问题：</h2><p>这里展示一个简易的用户表：</p><table><thead><tr><th>uid</th><th>username</th><th>password</th></tr></thead><tbody><tr><td>1</td><td>zhangsan</td><td>e10adc3949ba59abbe56e057f20f883e</td></tr><tr><td>2</td><td>lisi</td><td>e10adc3949ba59abbe56e057f20f883e</td></tr><tr><td>3</td><td>wangwu</td><td>9bd5ee6fe55aaeb673025dbcb8f939c1</td></tr><tr><td>4</td><td>laoz</td><td>f8a8d7997e870968f92748f3cc41cf90</td></tr></tbody></table><ol><li>我们发现 UID 1,2 对应的 password 是一样的，如果我是zhangsan，那岂不是同样我也知道lisi的密码明文是什么了？</li><li>通过MD5密码破解网站，轻易的得到 <code>e10adc3949ba59abbe56e057f20f883e</code> 对应的明文是 <code>123456</code></li></ol><a id="more"></a><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>我们知道，如果直接对密码进行散列，那么黑客可以对通过获得这个密码散列值，然后通过查散列值字典（例如MD5密码破解网站），得到某用户的密码。</p><p>加Salt可以一定程度上解决这一问题。所谓加Salt方法，就是加点“佐料”。其基本想法是这样的：当用户首次提供密码时（通常是注册时），由系统自动往这个密码里撒一些“佐料”，然后再散列。而当用户登录时，系统为用户提供的代码撒上同样的“佐料”，然后散列，再比较散列值，已确定密码是否正确。</p><p>这里的“佐料”被称作“Salt值”也称“盐值”，这个加“佐料”的行为叫做“加盐”，这个值是由系统随机生成的，并且只有系统知道。这样，即便两个用户使用了同一个密码，由于系统为它们生成的salt值不同，他们的散列值也是不同的。即便黑客可以通过自己的密码和自己生成的散列值来找具有特定密码的用户，但这个几率太小了（密码和salt值都得和黑客使用的一样才行）。</p><p>有时候，为了减轻开发压力，程序员会统一使用一个salt值（储存在某个地方），而不是每个用户都生成私有的salt值。但是这样的话还是解决不了上述我们发现同密文反推明文的问题。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">salt=random()<span class="comment">//获取一个随机的字符串</span></span><br><span class="line">src=<span class="number">123456</span></span><br><span class="line">password=md5(salt+src)</span><br></pre></td></tr></table></figure><p>下面详细介绍一下加Salt散列的过程。介绍之前先强调一点，前面说过，验证密码时要使用和最初散列密码时使用“相同的”佐料。所以Salt值是要存放在数据库里的。</p><h3 id="用户注册时"><a href="#用户注册时" class="headerlink" title="用户注册时"></a>用户注册时</h3><p>用户输入【账号】和【密码】（以及其他用户信息）；<br>系统为用户生成【Salt值】；<br>系统将【Salt值】和【用户密码】连接到一起；<br>对连接后的值进行散列，得到【Hash值】；<br>将【Hash值1】和【Salt值】分别放到数据库中。</p><h3 id="用户登录时"><a href="#用户登录时" class="headerlink" title="用户登录时"></a>用户登录时</h3><p>用户输入【账号】和【密码】；<br>系统通过用户名找到与之对应的【Hash值】和【Salt值】；<br>系统将【Salt值】和【用户输入的密码】连接到一起；<br>对连接后的值进行散列，得到【Hash值2】（注意是即时运算出来的值）；<br>比较【Hash值1】和【Hash值2】是否相等，相等则表示密码正确，否则表示密码错误。</p><h3 id="增强版用户表设计"><a href="#增强版用户表设计" class="headerlink" title="增强版用户表设计"></a>增强版用户表设计</h3><table><thead><tr><th>uid</th><th>username</th><th>password</th><th>salt</th></tr></thead><tbody><tr><td>1</td><td>zhangsan</td><td>ad4b3e001f961ef2792ccaae9d05c873</td><td>eyJ1a</td></tr><tr><td>2</td><td>lisi</td><td>f73f9c73c5e6e6059c9948a78ee81957</td><td>WQiOj</td></tr><tr><td>3</td><td>wangwu</td><td>9bd5ee6fe55aaeb673025dbcb8f939c1</td><td>EwMDE</td></tr><tr><td>4</td><td>laoz</td><td>f8a8d7997e870968f92748f3cc41cf90</td><td>U0MDk</td></tr></tbody></table><p>即便 zhangsan，lisi 的密码明文都是 123456，由于他们的salt不同则最终的password密文也不同，由于salt增加的密码的复杂度，被破解的难度也更大。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;发现问题：&quot;&gt;&lt;a href=&quot;#发现问题：&quot; class=&quot;headerlink&quot; title=&quot;发现问题：&quot;&gt;&lt;/a&gt;发现问题：&lt;/h2&gt;&lt;p&gt;这里展示一个简易的用户表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;uid&lt;/th&gt;
&lt;th&gt;username&lt;/th&gt;
&lt;th&gt;password&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;zhangsan&lt;/td&gt;
&lt;td&gt;e10adc3949ba59abbe56e057f20f883e&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;lisi&lt;/td&gt;
&lt;td&gt;e10adc3949ba59abbe56e057f20f883e&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;wangwu&lt;/td&gt;
&lt;td&gt;9bd5ee6fe55aaeb673025dbcb8f939c1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;laoz&lt;/td&gt;
&lt;td&gt;f8a8d7997e870968f92748f3cc41cf90&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;我们发现 UID 1,2 对应的 password 是一样的，如果我是zhangsan，那岂不是同样我也知道lisi的密码明文是什么了？&lt;/li&gt;
&lt;li&gt;通过MD5密码破解网站，轻易的得到 &lt;code&gt;e10adc3949ba59abbe56e057f20f883e&lt;/code&gt; 对应的明文是 &lt;code&gt;123456&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="算法" scheme="http://blog.fanfq.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://blog.fanfq.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="openapi" scheme="http://blog.fanfq.com/tags/openapi/"/>
    
  </entry>
  
  <entry>
    <title>Access Token &amp; Refresh Token</title>
    <link href="http://blog.fanfq.com/%E7%AE%97%E6%B3%95/AccessToken&amp;RefreshToken.html"/>
    <id>http://blog.fanfq.com/算法/AccessToken&amp;RefreshToken.html</id>
    <published>2018-10-30T14:26:57.000Z</published>
    <updated>2018-11-06T15:08:26.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计需求"><a href="#设计需求" class="headerlink" title="设计需求"></a>设计需求</h2><ol><li>统计在线列表，可以随时的踢下线，让客户端缓存的token失效</li><li>30天内无需重新登录，默认可无限期延续</li></ol><h2 id="Token生成方案"><a href="#Token生成方案" class="headerlink" title="Token生成方案"></a>Token生成方案</h2><a id="more"></a><h3 id="JWT（JSON-WEB-TOKEN）的构成"><a href="#JWT（JSON-WEB-TOKEN）的构成" class="headerlink" title="JWT（JSON WEB TOKEN）的构成"></a>JWT（JSON WEB TOKEN）的构成</h3><p>第一部分我们称它为头部（header),<br>第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，<br>第三部分是签名（signature确保数据的完整性).<br><code>JWT token = header.payload.signature</code><br>由于JWT是无状态的，也未能实现我们上述的需求，所以不得不放弃了JWT的方案，但是其有关token的加密算法还是值得参考的。</p><h3 id="access-token生成方案"><a href="#access-token生成方案" class="headerlink" title="access_token生成方案"></a>access_token生成方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">payload = urlencode(base64(&#123;uid,ts&#125;))</span><br><span class="line">salt=TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ //盐值</span><br><span class="line">signature = HMACSHA256(payload,salt);</span><br><span class="line">access_token = payload.signature</span><br><span class="line"></span><br><span class="line">redis_key = access_token:uid:&#123;access_token&#125;//uid 是从token中payload解析出来的</span><br><span class="line">redis_value = userinfo</span><br><span class="line">redis_ttl = 2hr</span><br></pre></td></tr></table></figure><h3 id="refresh-token生成方案"><a href="#refresh-token生成方案" class="headerlink" title="refresh_token生成方案"></a>refresh_token生成方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">payload = urlencode(base64(&#123;uid,ts&#125;))</span><br><span class="line">salt=TJVA95Or11.0cBab30RMHrHDcEfxjoYZgeFONFh7HgQ //盐值</span><br><span class="line">signature = HMACSHA256(payload,salt);</span><br><span class="line">refresh_token = payload.signature;</span><br><span class="line"></span><br><span class="line">redis_key = refresh_token:uid:&#123;refresh_token&#125;//uid 是从token中payload解析出来的</span><br><span class="line">redis_value = access_token</span><br><span class="line">redis_ttl = 30days</span><br></pre></td></tr></table></figure><h3 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"><span class="keyword">import</span> com.fanfq.util.commons.encrypt.HMACSHA256;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"\n#####token生成算法"</span>);</span><br><span class="line">    </span><br><span class="line">Long uid = <span class="number">10010l</span>;</span><br><span class="line"></span><br><span class="line">Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">    map.put(<span class="string">"uid"</span>, uid);</span><br><span class="line">    map.put(<span class="string">"ts"</span>, System.currentTimeMillis());</span><br><span class="line">    </span><br><span class="line">    String str = JSONObject.toJSONString(map);</span><br><span class="line">    </span><br><span class="line">    String base64 = Base64.encodeBase64String(str.getBytes());</span><br><span class="line">    String payload = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        payload = URLEncoder.encode(base64,<span class="string">"UTF-8"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">String salt = <span class="string">"TJVA95Or11.0cBab30RMHrHDcEfxjoYZgeFONFh7HgQ"</span>;</span><br><span class="line">String signature = HMACSHA256.encode(payload,salt);</span><br><span class="line"></span><br><span class="line">String token = payload+<span class="string">"."</span>+signature;</span><br><span class="line">System.out.println(<span class="string">"payload:"</span>+payload);</span><br><span class="line">System.out.println(<span class="string">"signature:"</span>+signature);</span><br><span class="line">System.out.println(<span class="string">"token:"</span>+token);</span><br><span class="line">System.out.println(<span class="string">"redis key: token:"</span>+uid+<span class="string">":"</span>+token);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"\n#####token校验算法"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"1.签名校验"</span>);</span><br><span class="line">System.out.println(<span class="string">"token:"</span>+token);</span><br><span class="line">String payload_ = token.split(<span class="string">"\\."</span>)[<span class="number">0</span>];</span><br><span class="line">String signature_ = token.split(<span class="string">"\\."</span>)[<span class="number">1</span>];</span><br><span class="line">System.out.println(<span class="string">"payload密文:"</span>+payload_);</span><br><span class="line">System.out.println(<span class="string">"signature签名:"</span>+signature_);</span><br><span class="line"><span class="keyword">boolean</span> check = HMACSHA256.encode(payload_,salt).equals(signature_);</span><br><span class="line">System.out.println(<span class="string">"签名校验："</span>+check);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"\n2.时间戳校验"</span>);</span><br><span class="line">String urldecode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    urldecode = URLDecoder.decode(payload_, <span class="string">"UTF-8"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">String jsondecode = <span class="keyword">new</span> String(Base64.decodeBase64(urldecode));</span><br><span class="line">System.out.println(<span class="string">"payload解密："</span>+jsondecode);</span><br><span class="line"></span><br><span class="line">JSONObject jsobj = JSONObject.parseObject(jsondecode);</span><br><span class="line">Long ts = jsobj.getLong(<span class="string">"ts"</span>);</span><br><span class="line">System.out.println(System.currentTimeMillis() - ts +<span class="string">" ms"</span>);</span><br><span class="line"><span class="keyword">if</span>(System.currentTimeMillis() - ts &gt; <span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">2</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"超过2小时"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"有效期内，开始进行redis查询"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>token生成算法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">明文：&#123;&quot;uid&quot;:10010,&quot;ts&quot;:1540912751948&#125;</span><br><span class="line">payload:eyJ1aWQiOjEwMDEwLCJ0cyI6MTU0MDkxMjc1MTk0OH0%3D</span><br><span class="line">signature:0ba40cff2bda8fab9ae61893b43c198e3022a1e8f058ac8054417241d3129d1f</span><br><span class="line">token:eyJ1aWQiOjEwMDEwLCJ0cyI6MTU0MDkxMjc1MTk0OH0%3D.0ba40cff2bda8fab9ae61893b43c198e3022a1e8f058ac8054417241d3129d1f</span><br><span class="line">redis key: token:10010:eyJ1aWQiOjEwMDEwLCJ0cyI6MTU0MDkxMjc1MTk0OH0%3D.0ba40cff2bda8fab9ae61893b43c198e3022a1e8f058ac8054417241d3129d1f</span><br></pre></td></tr></table></figure></p><p><strong>token校验算法</strong></p><ol><li><p>签名校验</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">token:eyJ1aWQiOjEwMDEwLCJ0cyI6MTU0MDkxMjc1MTk0OH0%3D.0ba40cff2bda8fab9ae61893b43c198e3022a1e8f058ac8054417241d3129d1f</span><br><span class="line">payload密文:eyJ1aWQiOjEwMDEwLCJ0cyI6MTU0MDkxMjc1MTk0OH0%3D</span><br><span class="line">signature签名:0ba40cff2bda8fab9ae61893b43c198e3022a1e8f058ac8054417241d3129d1f</span><br><span class="line">签名校验：true</span><br></pre></td></tr></table></figure></li><li><p>时间戳校验</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload解密：&#123;&quot;uid&quot;:10010,&quot;ts&quot;:1540912751948&#125;</span><br><span class="line">690 ms</span><br><span class="line">有效期内，开始进行redis查询</span><br></pre></td></tr></table></figure></li></ol><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>这个也是我经过思考后最终确认下来的token生成算法，也许你也发现既然redis持久化了就直接查库即可，无需搞的这么复杂的算法。实际上我是这样考虑的，因为大量的api请求都会带token参数导致每次请求都会查询库，固然redis的强大的性能足以支持，但还是为了效率过滤一些没有必要的io资源。</p><ol><li>得到请求的时候首先验证signature是否匹配，防止篡改</li><li>再从payload中获取ts以判断时间戳是否失效，access_token 2hr, refresh_token 30days.</li><li>前两者校验完成，则请求一次redis io做最终的判断。当然排除临时被提下线的情况下，大部分情况下这里都是通过的。</li><li><p>redis key 的设计，其中的uid设计主要是为了后期统计使用，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">keys （refresh_token:uid:*）获取当前终端连接数，</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; setz = jedis.keys(&quot;access_token:*&quot;);</span><br><span class="line">System.out.println(&quot;access_token:* key 的数目:&quot;+setz.size());</span><br><span class="line"></span><br><span class="line">获取当前在线用户数（根据uid排重）</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; setzz = new HashSet&lt;String&gt;();</span><br><span class="line">for(String str:setz) &#123;</span><br><span class="line">    setzz.add(str.split(&quot;:&quot;)[1]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;key uid 去重：&quot;+setzz.size());</span><br></pre></td></tr></table></figure></li><li><p>redis ttl 就不用不多说了，access_token 2hr, refresh_token 30days.</p></li><li>redis value：whatever anythings</li></ol><h3 id="Redis-有状态缓存"><a href="#Redis-有状态缓存" class="headerlink" title="Redis 有状态缓存"></a>Redis 有状态缓存</h3><p><strong>access_token</strong></p><table><thead><tr><th>key</th><th>ttl</th><th>value</th></tr></thead><tbody><tr><td>access_token:10024:ak_1</td><td>2hr</td><td>username:zhangsan,uid:10024</td></tr><tr><td>access_token:10025:ak_2</td><td>2hr</td><td>username:lisi,uid:10025</td></tr></tbody></table><p><strong>refresh_token</strong></p><table><thead><tr><th>key</th><th>ttl</th><th>value</th></tr></thead><tbody><tr><td>refresh_token:10024:rk_1</td><td>30days</td><td>access_token:10024:ak_1</td></tr><tr><td>refresh_token:10025:rk_2</td><td>30days</td><td>access_token:10025:ak_2</td></tr></tbody></table><h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h2><img src="/uploads/WX20181030-160602.png"><h2 id="用户授权获取token"><a href="#用户授权获取token" class="headerlink" title="用户授权获取token"></a>用户授权获取token</h2><h3 id="请求方法："><a href="#请求方法：" class="headerlink" title="请求方法："></a>请求方法：</h3><p><code>https://apihost/oauth2/access_token?username=zhangsan&amp;password=123456</code></p><h3 id="正确的返回："><a href="#正确的返回：" class="headerlink" title="正确的返回："></a>正确的返回：</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"code"</span>:<span class="number">200</span>,   </span><br><span class="line">   <span class="attr">"msg"</span>:<span class="string">"ok"</span>,   </span><br><span class="line">   <span class="attr">"data"</span>:&#123;</span><br><span class="line">      <span class="attr">"access_token"</span>:<span class="string">"ak_1"</span>,</span><br><span class="line">      <span class="attr">"uid"</span>:<span class="number">10024</span>,</span><br><span class="line">      <span class="attr">"refresh_token"</span>:<span class="string">"rk_1"</span>,</span><br><span class="line">      <span class="attr">"expires_in"</span>:<span class="number">7200</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>access_token</td><td>接口调用凭证</td></tr><tr><td>refresh_token</td><td>用户刷新access_token</td></tr><tr><td>uid</td><td>授权用户唯一标识</td></tr><tr><td>expires_in</td><td>access_token接口调用凭证超时时间，单位（秒）</td></tr></tbody></table><h3 id="错误返回样例："><a href="#错误返回样例：" class="headerlink" title="错误返回样例："></a>错误返回样例：</h3><p><code>{&quot;code&quot;:400,&quot;msg&quot;:&quot;bad request&quot;}</code></p><h2 id="刷新access-token有效期"><a href="#刷新access-token有效期" class="headerlink" title="刷新access_token有效期"></a>刷新access_token有效期</h2><p>access_token是调用授权关系接口的调用凭证，由于access_token有效期（目前为2个小时）较短，当access_token超时后，可以使用refresh_token进行刷新，用refresh_token仅能使用一次，使用一次后，将被废弃。也就是说refresh_token 更新 access_token 的时候 refresh_token 也会跟着被更新</p><ol><li>通过用refresh_token机制可以确保活跃用户长期不用登录授权。</li><li>refresh_token拥有较长的有效期（30天），当refresh_token失效的后，需要用户重新授权。也就说第一次登录与第二次登录时长间隔30天以上则需要用户重新授权登录。</li></ol><h3 id="请求方法：-1"><a href="#请求方法：-1" class="headerlink" title="请求方法："></a>请求方法：</h3><p><code>https://apihost/oauth2/refresh_token?uid=UID&amp;refresh_token=REFRESH_TOKEN</code></p><h3 id="正确的返回：-1"><a href="#正确的返回：-1" class="headerlink" title="正确的返回："></a>正确的返回：</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"code"</span>:<span class="number">200</span>,   </span><br><span class="line">   <span class="attr">"msg"</span>:<span class="string">"ok"</span>,   </span><br><span class="line">   <span class="attr">"data"</span>:&#123;</span><br><span class="line">      <span class="attr">"access_token"</span>:<span class="string">"ak_1"</span>,</span><br><span class="line">      <span class="attr">"uid"</span>:<span class="number">10024</span>,</span><br><span class="line">      <span class="attr">"refresh_token"</span>:<span class="string">"rk_1"</span>,</span><br><span class="line">      <span class="attr">"expires_in"</span>:<span class="number">7200</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>access_token</td><td>接口调用凭证</td></tr><tr><td>refresh_token</td><td>用户刷新access_token</td></tr><tr><td>uid</td><td>授权用户唯一标识</td></tr><tr><td>expires_in</td><td>access_token接口调用凭证超时时间，单位（秒）</td></tr></tbody></table><h3 id="错误返回样例：-1"><a href="#错误返回样例：-1" class="headerlink" title="错误返回样例："></a>错误返回样例：</h3><p><code>{&quot;code&quot;:400,&quot;msg&quot;:&quot;invalid refresh_token&quot;}</code></p><h2 id="通过access-token调用接口"><a href="#通过access-token调用接口" class="headerlink" title="通过access_token调用接口"></a>通过access_token调用接口</h2><p>获取access_token后，进行接口调用，有以下前提：<br>access_token有效且未超时；如果access_token失效，则通过refresh_token重新同步。若refresh_token也失效了则需要用户重新授权登录。</p><h3 id="Eg-通过UID获取用户基本信息"><a href="#Eg-通过UID获取用户基本信息" class="headerlink" title="Eg.通过UID获取用户基本信息"></a>Eg.通过UID获取用户基本信息</h3><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p><code>https://apihost/user?access_token=ak_1&amp;uid=10024</code></p><h3 id="正确的返回"><a href="#正确的返回" class="headerlink" title="正确的返回"></a>正确的返回</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"code"</span>:<span class="number">200</span>,   </span><br><span class="line">   <span class="attr">"msg"</span>:<span class="string">"ok"</span>,   </span><br><span class="line">   <span class="attr">"data"</span>:&#123;</span><br><span class="line">       <span class="attr">"username"</span>:<span class="string">"zhangsan"</span>,</span><br><span class="line">       <span class="attr">"age"</span>:<span class="number">28</span>,</span><br><span class="line">       <span class="attr">"address"</span>:<span class="string">"xx路xx号"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误返回样例：-2"><a href="#错误返回样例：-2" class="headerlink" title="错误返回样例："></a>错误返回样例：</h3><p><code>{&quot;code&quot;:400,&quot;msg&quot;:&quot;invalid access_token&quot;}</code></p><h2 id="注意事项RISK-CONTROL"><a href="#注意事项RISK-CONTROL" class="headerlink" title="注意事项RISK CONTROL"></a>注意事项RISK CONTROL</h2><ol><li>access_token 为用户授权客户端发起接口调用的凭证（相当于用户登录态），存储在客户端，可能出现恶意获取access_token 后导致的用户数据泄漏、用户微信相关接口功能被恶意发起等行为；</li><li>refresh_token 为用户授权客户端应用的长效凭证，仅用于刷新access_token，但泄漏后相当于access_token 泄漏，风险同上。</li><li>单点/多点登录。介于我们当前的设计不考虑单点登录的问题，也就是说同一个账号在不同的客户端都可以同时登录，并且生成不同的token以供使用每个客户端程序维护自己的一套token即可。倘若要实现单点登录则在用户授权的时候做排重判断，如果已在其他重点登录则清空该重点的token，并且为当前链接生成新token对即可。具体情况shi</li><li>用户信息跟新，针对我们当前的授权方式一旦用户修改的密码，则要清空该用户所有终端的token，让其重新授权。这也是为什么要设计这套有状态的token机制主要原因</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;设计需求&quot;&gt;&lt;a href=&quot;#设计需求&quot; class=&quot;headerlink&quot; title=&quot;设计需求&quot;&gt;&lt;/a&gt;设计需求&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;统计在线列表，可以随时的踢下线，让客户端缓存的token失效&lt;/li&gt;
&lt;li&gt;30天内无需重新登录，默认可无限期延续&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Token生成方案&quot;&gt;&lt;a href=&quot;#Token生成方案&quot; class=&quot;headerlink&quot; title=&quot;Token生成方案&quot;&gt;&lt;/a&gt;Token生成方案&lt;/h2&gt;
    
    </summary>
    
      <category term="算法" scheme="http://blog.fanfq.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://blog.fanfq.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="openapi" scheme="http://blog.fanfq.com/tags/openapi/"/>
    
  </entry>
  
  <entry>
    <title>Internal APIs encrypt Method V1.0</title>
    <link href="http://blog.fanfq.com/InternalAPIs_encrypt_Method_V1.0.html"/>
    <id>http://blog.fanfq.com/InternalAPIs_encrypt_Method_V1.0.html</id>
    <published>2018-10-29T13:56:43.000Z</published>
    <updated>2018-11-07T01:11:49.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单对称密码加密解密"><a href="#简单对称密码加密解密" class="headerlink" title="简单对称密码加密解密"></a>简单对称密码加密解密</h2><p>2018/10/19 我们发现大量的非法不带参数的Http请求访问我们的 apihost, 请求日志文件如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">183.223.44.221 - - [19/Oct/2018:16:47:32 +0800] &quot;POST /api_interface? HTTP/1.1&quot; 200 174 &quot;-&quot; &quot;okhttp/3.10.0&quot;</span><br><span class="line">请求者IP：183.223.44.221 </span><br><span class="line">请求接口：api_interface</span><br><span class="line">请求方式：POST</span><br><span class="line">请求者UA：okhttp/3.10.0</span><br></pre></td></tr></table></figure><p>问题引申：既然是非法请求，为什么黑客没有带参数的请求？<br>实际上这是一个很好的问题，如果接口没有做任何安全处理的话，黑客通过抓包很容易拿到请求参数规则，然后通过模拟请求达到目的。一旦接口做过”特殊工艺”处理了，黑客即将无处是从了。最终他们的心态都是从破解到放弃这样一个过程。</p><a id="more"></a><h2 id="正确的请求姿势："><a href="#正确的请求姿势：" class="headerlink" title="正确的请求姿势："></a>正确的请求姿势：</h2><p>实际上我们的设计接口的时候会有一个统一的接收参数 params 用来接收我们的数据，正确的请求如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">183.223.44.221 - - [19/Oct/2018:16:47:32 +0800] &quot;POST /api_interface?params=sM4AOVdWfPE4DxkXGEs8VFmEsZRgy58UYDPD7PjVYQXx1GEFrbjXMo11fb9x6ppwuaAeXV3n2DtoW4lG22nM0g HTTP/1.1&quot; 200 174 &quot;-&quot; &quot;okhttp/3.10.0&quot;</span><br><span class="line">请求者IP：183.223.44.221 </span><br><span class="line">请求接口：api_interface?params=sM4AOVdWfPE4DxkXGEs8VFmEsZRgy58UYDPD7PjVYQXx1GEFrbjXMo11fb9x6ppwuaAeXV3n2DtoW4lG22nM0g</span><br><span class="line">请求方式：POST</span><br><span class="line">请求者UA：okhttp/3.10.0</span><br></pre></td></tr></table></figure><h2 id="拓扑结构："><a href="#拓扑结构：" class="headerlink" title="拓扑结构："></a>拓扑结构：</h2><p>什么请求者IP,请求方式，UA都不是重点。重点在于我们的接口都会有一个params的参数，而这个参数的本身是通过加密算法形成的，即使黑客捕获到这串没有意义的密文也头疼。因为我们和客户端程序有规定所有请求的参数必须要用公钥加密后再通过特点的算法传递，同时服务器端返回的数据也是通过这套算法加密后传输。拓扑结构如下图。</p><img src="/uploads/WX20181029-223437@2x.png"><h2 id="为什么要数据加密？"><a href="#为什么要数据加密？" class="headerlink" title="为什么要数据加密？"></a>为什么要数据加密？</h2><p>安全，安全，安全。</p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>现在通过一个示例完整的描述一下我们的接口设计中加密解密过程。</p><p><strong>公钥</strong><br>上文中说道，我们同时约定了一套公钥给服务器端与客户端，为了配合下面的算法使用所以我们采用Int 类型的数字。现在定义为 KEY = 110; 为了确保安全性这个KEY只有内部知道。</p><p><strong>算法</strong></p><ul><li>XOR （with KEY）</li><li>BASE64 (encode/decode)</li><li>URLEncode/URLDecode</li></ul><h2 id="Eg-客户端-zhangsan-执行登录请求"><a href="#Eg-客户端-zhangsan-执行登录请求" class="headerlink" title="Eg.客户端 zhangsan 执行登录请求"></a>Eg.客户端 zhangsan 执行登录请求</h2><p><strong>将要发送的数据:</strong><br><code>{username:zhangsan,password:123456,action:login}</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; reqMap = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"><span class="keyword">int</span> key = <span class="number">110</span>;<span class="comment">//客户端与服务器端共同约定的公钥</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">be</span><span class="params">()</span> </span>&#123;</span><br><span class="line">reqMap.put(<span class="string">"username"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line">reqMap.put(<span class="string">"password"</span>, <span class="string">"123456"</span>);</span><br><span class="line">reqMap.put(<span class="string">"action"</span>, <span class="string">"login"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加密算法 （java实现）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.xor</span></span><br><span class="line"><span class="keyword">byte</span>[] byteArry = reqMap.toString().getBytes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; byteArry.length; i++) &#123;</span><br><span class="line">    byteArry[i] = (<span class="keyword">byte</span>) (byteArry[i] ^ key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.base64.ecode</span></span><br><span class="line">String encode = <span class="keyword">new</span> BASE64Encoder().encode(byteArry);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.url.encode</span></span><br><span class="line">String dist = URLEncoder.encode(encode, <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"params="</span>+dist);</span><br></pre></td></tr></table></figure></p><p>输出的params为:<br><code>params=FR4PHR0ZARwKU19cXVpbWEJODw0aBwEAUwIBCQcAQk4bHQscAA8DC1MUBg8ACR0PABM%3D</code></p><p><strong>解密算法 （java实现）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String params = <span class="string">"FR4PHR0ZARwKU19cXVpbWEJODw0aBwEAUwIBCQcAQk4bHQscAA8DC1MUBg8ACR0PABM%3D"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.url.decode</span></span><br><span class="line">String decode = URLDecoder.decode(params, <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.base64.decode</span></span><br><span class="line"><span class="keyword">byte</span>[] byteArry = <span class="keyword">new</span> BASE64Decoder().decodeBuffer(decode);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.xor</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; byteArry.length; i++) &#123;</span><br><span class="line">    byteArry[i] = (<span class="keyword">byte</span>) (byteArry[i] ^ key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"dist:"</span>+<span class="keyword">new</span> String(byteArry));</span><br></pre></td></tr></table></figure></p><p>输出的dist为：<br><code>dist={username:zhangsan,password:123456,action:login}</code></p><h2 id="对称加密优缺点"><a href="#对称加密优缺点" class="headerlink" title="对称加密优缺点"></a>对称加密优缺点</h2><p>对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。适用于简单的报文加密，同时也使用用大报文加密。<br>对称加密算法的缺点是在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。</p><h2 id="常用的对称密钥算法"><a href="#常用的对称密钥算法" class="headerlink" title="常用的对称密钥算法"></a>常用的对称密钥算法</h2><p>加密和解密都使用同一把秘钥，这种加密方法称为对称加密，也称为单密钥加密。<br>简单理解为：加密解密都是同一把钥匙。<br>AES、DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK 等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单对称密码加密解密&quot;&gt;&lt;a href=&quot;#简单对称密码加密解密&quot; class=&quot;headerlink&quot; title=&quot;简单对称密码加密解密&quot;&gt;&lt;/a&gt;简单对称密码加密解密&lt;/h2&gt;&lt;p&gt;2018/10/19 我们发现大量的非法不带参数的Http请求访问我们的 apihost, 请求日志文件如下所示。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;183.223.44.221 - - [19/Oct/2018:16:47:32 +0800] &amp;quot;POST /api_interface? HTTP/1.1&amp;quot; 200 174 &amp;quot;-&amp;quot; &amp;quot;okhttp/3.10.0&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;请求者IP：183.223.44.221 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;请求接口：api_interface&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;请求方式：POST&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;请求者UA：okhttp/3.10.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;问题引申：既然是非法请求，为什么黑客没有带参数的请求？&lt;br&gt;实际上这是一个很好的问题，如果接口没有做任何安全处理的话，黑客通过抓包很容易拿到请求参数规则，然后通过模拟请求达到目的。一旦接口做过”特殊工艺”处理了，黑客即将无处是从了。最终他们的心态都是从破解到放弃这样一个过程。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://blog.fanfq.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://blog.fanfq.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="openapi" scheme="http://blog.fanfq.com/tags/openapi/"/>
    
  </entry>
  
  <entry>
    <title>Open APIs encrypt Method V1.1</title>
    <link href="http://blog.fanfq.com/%E7%AE%97%E6%B3%95/OpenAPIs_encrypt_Method_V1.1.html"/>
    <id>http://blog.fanfq.com/算法/OpenAPIs_encrypt_Method_V1.1.html</id>
    <published>2018-10-29T06:57:41.000Z</published>
    <updated>2018-11-06T14:17:45.754Z</updated>
    
    <content type="html"><![CDATA[<h2 id="非对称密码加密解密-amp-签名机制-amp-重放攻击"><a href="#非对称密码加密解密-amp-签名机制-amp-重放攻击" class="headerlink" title="非对称密码加密解密&amp;签名机制&amp;重放攻击"></a>非对称密码加密解密&amp;签名机制&amp;重放攻击</h2><p>《Internal APIs encrypt Method V1.0》 文章中已经描述了我们正在线上产品所用的加密算法，实际上他不仅仅是解决防参数篡改的问题，同时也解决了数据隐私保护的问题。即便如此这套算法还是有漏洞的，也是做所以定义为 Internal APIs的主要原因了，由于只提供给内部使用所以安全性暂且得到保障，一旦提供给外部使用则全盘”露馅”了,这也是我为什么要编辑此篇《Open APIs encrypt Method V1.1》文章了。</p><p>其中最为致命的问题是要在客户端代码中公开自己的密钥以及算法，一旦黑客从客户端程序中反编译源码，这样就会导致整个加密体系的崩盘，而且连补救的措施都没有。</p><p>同时第二个比较严重的问题就是黑客从放攻击的问题，黑客在抓取到包体后，直接再次提交请求导致服务器端不断受到重复请求。</p><p>所以基于以上两点，我们了解到《Internal APIs encrypt Method V1.0》所存在的问题如下表所示</p><a id="more"></a><table><thead><tr><th>问题描述</th><th>安全性</th><th>解决方案</th></tr></thead><tbody><tr><td>脱敏（数据隐私保护）</td><td>安全</td><td></td></tr><tr><td>完整性 （防参数篡改）</td><td>安全</td><td></td></tr><tr><td>重放攻击 （重复提交）</td><td>未解决</td><td>timestamp + nonce</td></tr><tr><td>对称密钥</td><td>不够安全</td><td>非对称密钥</td></tr></tbody></table><h2 id="签名机制："><a href="#签名机制：" class="headerlink" title="签名机制："></a>签名机制：</h2><p>所以本文重点就是要解决 重放攻击 (重复提交) &amp; 密钥安全 这两个问题。在此之前再介绍一种常用的解决数据传输过程中确保完整性 （防参数篡改）的解决方案，过程如下：</p><ol><li>客户端使用约定好的秘钥对传输参数进行加密，得到签名值signature，并且将签名值也放入请求参数中，发送请求给服务端</li><li>服务端接收客户端的请求，然后使用约定好的秘钥对请求的参数（除了signature以外）再次进行签名，得到签名值autograph。</li><li>服务端对比signature和autograph的值，如果对比一致，认定为合法请求。如果对比不一致，说明参数被篡改，认定为非法请求。</li></ol><h3 id="Eg-客户端-zhangsan-执行登录请求"><a href="#Eg-客户端-zhangsan-执行登录请求" class="headerlink" title="Eg.客户端 zhangsan 执行登录请求"></a>Eg.客户端 zhangsan 执行登录请求</h3><p>将要发送的数据：<br><code>apihost?action=login&amp;username=zhangsan&amp;password=123456&amp;sign=</code></p><h3 id="签名算法：-java-实现"><a href="#签名算法：-java-实现" class="headerlink" title="签名算法：(java 实现)"></a>签名算法：(java 实现)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.对除sign外的所有参数按字典排序 对所有待签名参数按照字段名的 ASCII码从小到大排序（字典序）后</span></span><br><span class="line">String[] arr =  <span class="keyword">new</span> String[] &#123; <span class="string">"username=zhangsan"</span>,<span class="string">"password=123456"</span>, <span class="string">"action=login"</span>&#125;;</span><br><span class="line">Arrays.sort(arr); </span><br><span class="line"></span><br><span class="line"><span class="comment">//2.将排序后的结果拼接成一个字符串（即key1=value1&amp;key2=value2…）</span></span><br><span class="line">String content = arr[<span class="number">0</span>].concat(<span class="string">"&amp;"</span>+arr[<span class="number">1</span>]).concat(<span class="string">"&amp;"</span>+arr[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、将字符串进行sha1加密得到sign值</span></span><br><span class="line">MessageDigest md = <span class="keyword">null</span>;</span><br><span class="line">String sign = <span class="keyword">null</span>;  </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    md = MessageDigest.getInstance(<span class="string">"SHA-1"</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] digest = md.digest(content.toString().getBytes());</span><br><span class="line">    sign = StrUtil.byteToStr(digest);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"sign="</span>+sign);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出的sign为:<br><code>sign=ebb36366bd9d8656e2327ca913a4f854f35a0e95</code></p><h3 id="最终请求服务器的数据为："><a href="#最终请求服务器的数据为：" class="headerlink" title="最终请求服务器的数据为："></a>最终请求服务器的数据为：</h3><p><code>apihost?action=login&amp;username=zhangsan&amp;password=123456&amp;sign=ebb36366bd9d8656e2327ca913a4f854f35a0e95</code></p><p>当服务器拿到数据后再进行同样的算法然后再匹配sign值是否一致，如果对比一致，认定为合法请求。如果对比不一致，说明参数被篡改，认定为非法请求。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ol><li>参数排序很重要，不同的排序会导致签名值不一致。所以要事先规定好排序算法。</li><li>sign算法也要事先规定好，示例中是一个简单的算法并没有使用到密钥。实际过程中可能更加复杂签名的秘钥我们可以使用很多方案，可以采用对称加密或者非对称加密。</li><li>因为黑客不知道签名的秘钥，也不知道签名的算法，所以即使截取到请求数据，对请求参数进行篡改，但是却无法对参数进行签名，无法得到修改后参数的签名值signature。</li><li>示例中并没有解决数据脱敏的问题，应用过程中可以根据实际情况再进行脱敏算法。</li></ol><h2 id="防止重放攻击"><a href="#防止重放攻击" class="headerlink" title="防止重放攻击"></a>防止重放攻击</h2><h3 id="基于timestamp的方案"><a href="#基于timestamp的方案" class="headerlink" title="基于timestamp的方案"></a>基于timestamp的方案</h3><p>每次HTTP请求，都需要加上timestamp参数，然后把timestamp和其他参数一起进行数字签名。因为一次正常的HTTP请求，从发出到达服务器一般都不会超过60s，所以服务器收到HTTP请求之后，首先判断时间戳参数与当前时间相比较，是否超过了60s，如果超过了则认为是非法的请求。</p><p>一般情况下，黑客从抓包重放请求耗时远远超过了60s，所以此时请求中的timestamp参数已经失效了。</p><p>如果黑客修改timestamp参数为当前的时间戳，则signature参数对应的数字签名就会失效，因为黑客不知道签名秘钥，没有办法生成新的数字签名。</p><p>但这种方式的漏洞也是显而易见的，如果在60s之后进行重放攻击，那就没办法了，所以这种方式不能保证请求仅一次有效。</p><h3 id="基于nonce的方案"><a href="#基于nonce的方案" class="headerlink" title="基于nonce的方案"></a>基于nonce的方案</h3><p>nonce的意思是仅一次有效的随机字符串，要求每次请求时，该参数要保证不同，所以该参数一般与时间戳有关，我们这里为了方便起见，直接使用时间戳的16进制，实际使用时可以加上客户端的ip地址，mac地址等信息做个哈希之后，作为nonce参数。</p><p>我们将每次请求的nonce参数存储到一个“集合”中，可以json格式存储到数据库或缓存中。</p><p>每次处理HTTP请求时，首先判断该请求的nonce参数是否在该“集合”中，如果存在则认为是非法请求。</p><p>nonce参数在首次请求时，已经被存储到了服务器上的“集合”中，再次发送请求会被识别并拒绝。</p><p>nonce参数作为数字签名的一部分，是无法篡改的，因为黑客不清楚token，所以不能生成新的sign。</p><p>这种方式也有很大的问题，那就是存储nonce参数的“集合”会越来越大，验证nonce是否存在“集合”中的耗时会越来越长。我们不能让nonce“集合”无限大，所以需要定期清理该“集合”，但是一旦该“集合”被清理，我们就无法验证被清理了的nonce参数了。也就是说，假设该“集合”平均1天清理一次的话，我们抓取到的该url，虽然当时无法进行重放攻击，但是我们还是可以每隔一天进行一次重放攻击的。而且存储24小时内，所有请求的“nonce”参数，也是一笔不小的开销。</p><h3 id="基于timestamp和nonce的方案"><a href="#基于timestamp和nonce的方案" class="headerlink" title="基于timestamp和nonce的方案"></a>基于timestamp和nonce的方案</h3><p>nonce的一次性可以解决timestamp参数60s的问题，timestamp可以解决nonce参数“集合”越来越大的问题。<br>防止重放攻击一般和防止请求参数被串改一起做，请求的Headers数据如下图所示。</p><p>我们在timestamp方案的基础上，加上nonce参数，因为timstamp参数对于超过60s的请求，都认为非法请求，所以我们只需要存储60s的nonce参数的“集合”即可。</p><h4 id="HTTP请求头，参数说明："><a href="#HTTP请求头，参数说明：" class="headerlink" title="HTTP请求头，参数说明："></a>HTTP请求头，参数说明：</h4><p>由于每次数据请求都要带上这几个参数，所以直接将这几个参数设置在请求头中，从而简化body长度；当然也可以在去请求参数中拼凑视具体情况而定。</p><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>token</td><td>用户令牌，用于认证用户身份</td><td>稍微长一点的文本</td></tr><tr><td>sign</td><td>签名，用于监测请求数据的完整性</td><td>中等文本</td></tr><tr><td>timestamp</td><td>请求时间戳</td><td>根据的约定的保留毫秒或者精度到秒</td></tr><tr><td>nonce</td><td>请求随机字符串: MD5(时间戳+随机字符)</td><td>单位时间内产生不重复字符就好</td></tr></tbody></table><p>有关token的详细说明，请查看《Access Token &amp; Refresh Token 机制》这篇文章</p><h4 id="服务器端校验："><a href="#服务器端校验：" class="headerlink" title="服务器端校验："></a>服务器端校验：</h4><p>服务器端的校验配置通常会放在Filter / Interceptor 中,作为全局的管理。<br>nonce参数通常会存在redis中，并且设置TTL过期时间。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">String token = request.getHeader(<span class="string">"token"</span>);</span><br><span class="line">String timestamp = request.getHeader(<span class="string">"timestamp"</span>);</span><br><span class="line">String nonce = request.getHeader(<span class="string">"nonce"</span>);</span><br><span class="line">String sign = request.getHeader(<span class="string">"sign"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间限制配置 s</span></span><br><span class="line"><span class="keyword">int</span> timeLimit = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求头参数非空验证</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(token) || StringUtils.isEmpty(timestamp) || StringUtils.isEmpty(nonce) || StringUtils.isEmpty(sign)) &#123;</span><br><span class="line">    ctx.setResponseBody(JSON.toJSONString(<span class="keyword">new</span> Result(<span class="string">"-1"</span>, <span class="string">"请求头参数不正确"</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求时间和现在时间对比验证，发起请求时间和服务器时间不能超过timeLimit秒</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.timeDiffSeconds(<span class="keyword">new</span> Date(), timestamp) &gt; timeLimit) &#123;</span><br><span class="line">    ctx.setResponseBody(JSON.toJSONString(<span class="keyword">new</span> Result(<span class="string">"-1"</span>, <span class="string">"请求发起时间超过服务器限制"</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证用户信息</span></span><br><span class="line">UserInfo userInfo = UserInfoUtil.getInfoByToken(token);</span><br><span class="line"><span class="keyword">if</span> (userInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ctx.setResponseBody(JSON.toJSONString(<span class="keyword">new</span> Result(<span class="string">"-1"</span>, <span class="string">"错误的token信息"</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证相同noce的请求是否已经存在，存在表示为重复请求</span></span><br><span class="line"><span class="keyword">if</span> (NoceUtil.exsit(userInfo, nonce)) &#123;</span><br><span class="line">    ctx.setResponseBody(JSON.toJSONString(<span class="keyword">new</span> Result(<span class="string">"-1"</span>, <span class="string">"重复的请求"</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果noce没有在缓存中，则需要加入，并设置过期时间为timeLimit秒</span></span><br><span class="line">    NoceUtil.addNoce(userInfo, nonce, timeLimit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器生成签名与header中签名对比</span></span><br><span class="line">String serverSign = SignUtil.getSign(userinfo, token, timestamp, nonce, request);</span><br><span class="line"><span class="keyword">if</span> (!serverSign.equals(sign)) &#123;</span><br><span class="line">    ctx.setResponseBody(JSON.toJSONString(<span class="keyword">new</span> Result(<span class="string">"-1"</span>, <span class="string">"错误的签名信息"</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="非对称密钥"><a href="#非对称密钥" class="headerlink" title="非对称密钥"></a>非对称密钥</h2><h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><p>与对称密钥不同，非对称密钥要有一组密钥分别是公钥和私钥，通常情况下公钥加密，私钥解密。公钥可以发布给任意的客户端程序，服务器端则通过私钥解密。以下是非对称密钥的拓扑结构。</p><img src="/uploads/WX20181029-223454@2x.png"><p>如上图所以，发送者用接收方公开出来的公钥PK进行加密。接受方在收到密文后，再用与公钥对应的私钥SK进行解密。同样，密文即便被截获，但是由于截获者只有公钥，没有私钥，他不能进行解密</p><h3 id="非对称加密优缺点"><a href="#非对称加密优缺点" class="headerlink" title="非对称加密优缺点"></a>非对称加密优缺点</h3><p>非对称加密的突出优点是用于解密的密钥（也就是私钥）永远不需要传递给对方。但是，它的缺点也很突出：非对称加密算法复杂，导致加解密速度慢，故只适合小量数据的场合。而对称加密加解密效率高，系统开销小，适合进行大数据量的加解密。由于文件一般比较大，这个特性决定了适合它的加密方式最好是对称加密。</p><h3 id="Eg-RSA对称密钥算法（java实现）"><a href="#Eg-RSA对称密钥算法（java实现）" class="headerlink" title="Eg.RSA对称密钥算法（java实现）"></a>Eg.RSA对称密钥算法（java实现）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.fanfq.util.commons.encrypt.rsa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">    &lt;groupId&gt;commons-codec&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">    &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">    &lt;version&gt;1.11&lt;/version&gt;</span></span><br><span class="line"><span class="comment">&lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">https://www.jianshu.com/p/ff8281f034f4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fred</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSAUtil2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_ALGORITHM = <span class="string">"RSA"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SIGNATURE_ALGORITHM = <span class="string">"MD5withRSA"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PUBLIC_KEY = <span class="string">"RSAPublicKey"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRIVATE_KEY = <span class="string">"RSAPrivateKey"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptBASE64(String key) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.decodeBase64(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encryptBASE64</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用私钥对信息生成数字签名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data       加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sign</span><span class="params">(String data, String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 解密由base64编码的私钥</span></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = decryptBASE64(privateKey);</span><br><span class="line">        <span class="comment">// 构造PKCS8EncodedKeySpec对象</span></span><br><span class="line">        PKCS8EncodedKeySpec pkcs8KeySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line">        <span class="comment">// KEY_ALGORITHM 指定的加密算法</span></span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="comment">// 取私钥匙对象</span></span><br><span class="line">        PrivateKey priKey = keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        <span class="comment">// 用私钥对信息生成数字签名</span></span><br><span class="line">        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">        signature.initSign(priKey);</span><br><span class="line">        signature.update(data.getBytes());</span><br><span class="line">        <span class="keyword">return</span> encryptBASE64(signature.sign());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验数字签名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sign      数字签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 校验成功返回true 失败返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String data, String publicKey, String sign)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 解密由base64编码的公钥</span></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = decryptBASE64(publicKey);</span><br><span class="line">        <span class="comment">// 构造X509EncodedKeySpec对象</span></span><br><span class="line">        X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line">        <span class="comment">// KEY_ALGORITHM 指定的加密算法</span></span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="comment">// 取公钥匙对象</span></span><br><span class="line">        PublicKey pubKey = keyFactory.generatePublic(keySpec);</span><br><span class="line">        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">        signature.initVerify(pubKey);</span><br><span class="line">        signature.update(data.getBytes());</span><br><span class="line">        <span class="comment">// 验证签名是否正常</span></span><br><span class="line">        <span class="keyword">return</span> signature.verify(decryptBASE64(sign));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptByPrivateKey(<span class="keyword">byte</span>[] data, String key) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 对密钥解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得私钥</span></span><br><span class="line">        PKCS8EncodedKeySpec pkcs8KeySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        Key privateKey = keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        <span class="comment">// 对数据解密</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 用私钥解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptByPrivateKey(String data, String key)</span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> decryptByPrivateKey(decryptBASE64(data),key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 用公钥解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decryptByPublicKey</span><span class="params">(String data, String key)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] datas = decryptBASE64(data);</span><br><span class="line">        <span class="comment">// 对密钥解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得公钥</span></span><br><span class="line">        X509EncodedKeySpec x509KeySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        Key publicKey = keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">        <span class="comment">// 对数据解密</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(cipher.doFinal(datas));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 用公钥加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encryptByPublicKey</span><span class="params">(String data, String key)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 对公钥解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得公钥</span></span><br><span class="line">        X509EncodedKeySpec x509KeySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        Key publicKey = keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">        <span class="comment">// 对数据加密</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">return</span> encryptBASE64(cipher.doFinal(data.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 用私钥加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encryptByPrivateKey</span><span class="params">(String data, String key)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 对密钥解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得私钥</span></span><br><span class="line">        PKCS8EncodedKeySpec pkcs8KeySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        Key privateKey = keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        <span class="comment">// 对数据加密</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">return</span> encryptBASE64(cipher.doFinal(data.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得私钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPrivateKey</span><span class="params">(Map&lt;String, Key&gt; keyMap)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Key key = (Key) keyMap.get(PRIVATE_KEY);</span><br><span class="line">        <span class="keyword">return</span> encryptBASE64(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得公钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPublicKey</span><span class="params">(Map&lt;String, Key&gt; keyMap)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Key key = keyMap.get(PUBLIC_KEY);</span><br><span class="line">        <span class="keyword">return</span> encryptBASE64(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化密钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Key&gt; <span class="title">initKey</span><span class="params">(<span class="keyword">int</span> length)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyPairGenerator keyPairGen = KeyPairGenerator</span><br><span class="line">                .getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="keyword">if</span>(length != <span class="number">2048</span>) length = <span class="number">1024</span>;</span><br><span class="line">        keyPairGen.initialize(length);</span><br><span class="line">        KeyPair keyPair = keyPairGen.generateKeyPair();</span><br><span class="line">        Map&lt;String, Key&gt; keyMap = <span class="keyword">new</span> HashMap(<span class="number">2</span>);</span><br><span class="line">        keyMap.put(PUBLIC_KEY, keyPair.getPublic());<span class="comment">// 公钥</span></span><br><span class="line">        keyMap.put(PRIVATE_KEY, keyPair.getPrivate());<span class="comment">// 私钥</span></span><br><span class="line">        <span class="keyword">return</span> keyMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanfq.util.commons.encrypt.rsa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.security.Key;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSAUtil2Test</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String publicKey;</span><br><span class="line">    <span class="keyword">private</span> String privateKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;String, Key&gt; keyMap = RSAUtil2.initKey(<span class="number">2048</span>);</span><br><span class="line">        publicKey = RSAUtil2.getPublicKey(keyMap);</span><br><span class="line">        privateKey = RSAUtil2.getPrivateKey(keyMap);</span><br><span class="line">        System.out.println(<span class="string">"公钥:"</span> + publicKey.length());</span><br><span class="line">        System.out.println(publicKey);</span><br><span class="line">        System.out.println(<span class="string">"私钥:"</span> + privateKey.length());</span><br><span class="line">        System.out.println(privateKey);</span><br><span class="line">        </span><br><span class="line">        ObjectOutputStream oos1 = <span class="keyword">null</span>;  </span><br><span class="line">        ObjectOutputStream oos2 = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">/** 用对象流将生成的密钥写入文件 */</span>  </span><br><span class="line">            oos1 = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"RSA_PUBLIC_KEY"</span>));  </span><br><span class="line">            oos2 = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"RSA_PRIVATE_KEY"</span>));  </span><br><span class="line">            oos1.writeObject(publicKey);  </span><br><span class="line">            oos2.writeObject(privateKey);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> e;  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            <span class="comment">/** 清空缓存，关闭文件输出流 */</span>  </span><br><span class="line">            oos1.close();  </span><br><span class="line">            oos2.close();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"\n-------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"公钥加密——私钥解密"</span>);</span><br><span class="line">        String inputStr = <span class="string">"dounine"</span>;</span><br><span class="line">        String encodedData = RSAUtil2.encryptByPublicKey(inputStr, publicKey);</span><br><span class="line">        <span class="keyword">byte</span>[] decodedData = RSAUtil2.decryptByPrivateKey(encodedData,</span><br><span class="line">                privateKey);</span><br><span class="line">        String outputStr = <span class="keyword">new</span> String(decodedData);</span><br><span class="line">        System.out.println(<span class="string">"加密前: "</span> + inputStr);</span><br><span class="line">        System.out.println(<span class="string">"公钥加密后: "</span> + encodedData);</span><br><span class="line">        System.out.println(<span class="string">"私钥解密后: "</span> + outputStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSign</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"\n-------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"私钥加密——公钥解密"</span>);</span><br><span class="line">        String inputStr = <span class="string">"dounine"</span>;</span><br><span class="line">        String encodedData = RSAUtil2.encryptByPrivateKey(inputStr, privateKey);</span><br><span class="line">        String decodedData = RSAUtil2.decryptByPublicKey(encodedData, publicKey);</span><br><span class="line">        System.out.println(<span class="string">"加密前: "</span> + inputStr);</span><br><span class="line">        System.out.println(<span class="string">"私钥加密后: "</span> + encodedData);</span><br><span class="line">        System.out.println(<span class="string">"公钥解密后: "</span> + decodedData);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"\n私钥签名——公钥验证签名"</span>);</span><br><span class="line">        <span class="comment">// 产生签名</span></span><br><span class="line">        String sign = RSAUtil2.sign(<span class="string">"123"</span>, privateKey);</span><br><span class="line">        System.out.println(<span class="string">"私钥签名:("</span>+sign.length()+<span class="string">")"</span> + sign);</span><br><span class="line">        <span class="comment">// 验证签名</span></span><br><span class="line">        <span class="keyword">boolean</span> status = RSAUtil2.verify(encodedData, publicKey, sign);</span><br><span class="line">        System.out.println(<span class="string">"公钥验证签名:"</span> + status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    RSAUtil2Test rsa = <span class="keyword">new</span> RSAUtil2Test();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      rsa.setUp();</span><br><span class="line">      rsa.test();</span><br><span class="line">      rsa.testSign();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;非对称密码加密解密-amp-签名机制-amp-重放攻击&quot;&gt;&lt;a href=&quot;#非对称密码加密解密-amp-签名机制-amp-重放攻击&quot; class=&quot;headerlink&quot; title=&quot;非对称密码加密解密&amp;amp;签名机制&amp;amp;重放攻击&quot;&gt;&lt;/a&gt;非对称密码加密解密&amp;amp;签名机制&amp;amp;重放攻击&lt;/h2&gt;&lt;p&gt;《Internal APIs encrypt Method V1.0》 文章中已经描述了我们正在线上产品所用的加密算法，实际上他不仅仅是解决防参数篡改的问题，同时也解决了数据隐私保护的问题。即便如此这套算法还是有漏洞的，也是做所以定义为 Internal APIs的主要原因了，由于只提供给内部使用所以安全性暂且得到保障，一旦提供给外部使用则全盘”露馅”了,这也是我为什么要编辑此篇《Open APIs encrypt Method V1.1》文章了。&lt;/p&gt;
&lt;p&gt;其中最为致命的问题是要在客户端代码中公开自己的密钥以及算法，一旦黑客从客户端程序中反编译源码，这样就会导致整个加密体系的崩盘，而且连补救的措施都没有。&lt;/p&gt;
&lt;p&gt;同时第二个比较严重的问题就是黑客从放攻击的问题，黑客在抓取到包体后，直接再次提交请求导致服务器端不断受到重复请求。&lt;/p&gt;
&lt;p&gt;所以基于以上两点，我们了解到《Internal APIs encrypt Method V1.0》所存在的问题如下表所示&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://blog.fanfq.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://blog.fanfq.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="openapi" scheme="http://blog.fanfq.com/tags/openapi/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://blog.fanfq.com/hello-wolrd.html"/>
    <id>http://blog.fanfq.com/hello-wolrd.html</id>
    <published>2012-10-31T01:14:33.000Z</published>
    <updated>2018-11-07T02:28:06.883Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! </p><p><code>文本</code></p><p>This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><table><thead><tr><th>uid</th><th>username</th><th>password</th></tr></thead><tbody><tr><td>1</td><td>zhangsan</td><td>ad4b3e001f961ef2792ccaae9d05c873</td></tr><tr><td>2</td><td>lisi</td><td>f73f9c73c5e6e6059c9948a78ee81957</td></tr><tr><td>3</td><td>wangwu</td><td>9bd5ee6fe55aaeb673025dbcb8f939c1</td></tr><tr><td>4</td><td>laoz</td><td>f8a8d7997e870968f92748f3cc41cf90</td></tr></tbody></table><img src="/uploads/WX20181029-223437@2x.png"><!-- 标签别名 --><blockquote class="blockquote-center"><p>blah blah blah </p></blockquote><p>Lorem <span class="label default">ipsum</span> <span class="label primary">dolor sit</span> amet, consectetur <span class="label success">adipiscing elit,</span> sed <span class="label info">do eiusmod</span> tempor incididunt ut labore et dolore magna aliqua.</p><p>Ut enim <em><span class="label warning">ad</span></em> minim veniam, quis <strong><span class="label danger">nostrud</span></strong> exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p><p>Duis aute irure dolor in reprehenderit in voluptate <del><span class="label default">velit</span></del> <mark>esse</mark> cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>一个普通标题</th><th>一个普通标题</th><th>一个普通标题</th></tr></thead><tbody><tr><td>短文本</td><td>中等文本</td><td>稍微长一点的文本</td></tr><tr><td>稍微长一点的文本</td><td>短文本</td><td>中等文本</td></tr></tbody></table><p><a href="https://theme-next.iissnan.com/tag-plugins.html#center-blockquote-usage" target="_blank" rel="noopener">https://theme-next.iissnan.com/tag-plugins.html#center-blockquote-usage</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! &lt;/p&gt;
&lt;p&gt;&lt;code&gt;文本&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Testing" scheme="http://blog.fanfq.com/categories/Testing/"/>
    
    
  </entry>
  
</feed>
