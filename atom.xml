<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fred&#39;s Blog</title>
  
  <subtitle>Quick notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.fanfq.com/"/>
  <updated>2021-08-12T07:34:18.166Z</updated>
  <id>https://blog.fanfq.com/</id>
  
  <author>
    <name>Fred范方青</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>游戏行业已与我渐行渐远，曾经我以他谋生</title>
    <link href="https://blog.fanfq.com/blog/%E6%B8%B8%E6%88%8F%E8%A1%8C%E4%B8%9A%E5%B7%B2%E4%B8%8E%E6%88%91%E6%B8%90%E8%A1%8C%E6%B8%90%E8%BF%9C%EF%BC%8C%E6%9B%BE%E7%BB%8F%E6%88%91%E4%BB%A5%E4%BB%96%E8%B0%8B%E7%94%9F.html"/>
    <id>https://blog.fanfq.com/blog/游戏行业已与我渐行渐远，曾经我以他谋生.html</id>
    <published>2021-08-12T06:59:44.000Z</published>
    <updated>2021-08-12T07:34:18.166Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数年游戏行业从业经历，一路过来的心路历程，我不玩手游，不玩网游，今天告诉你我在玩什么？我在怎么玩？</p><p>当时每年都会参加不同的展会，如ChinaJoy，GMGC 等但凡有点规模的我都参加过，也代表公司设立过展台。</p><img src="https://cdn.fanfq.com/picgo/20210812150054.jpg?imageslim," title="GMGC"><img src="https://cdn.fanfq.com/picgo/20210812150129.jpg?imageslim," title="ChinaJoy"><p>我找了好久才找到这两张照片，回顾一下这几年我发过的朋友圈，绝大多数都没有我真人出境的照片，基本都是只拍了个展台，或者拍了下工作证。真的蛮可惜的，好在还找到了两张分别代表GMGC 和 ChinaJoy 的。</p><p>写到这里，我似乎觉得我要和游戏行业说再见了。这几年在游戏行业经历了太多的人和事，也见证了游戏行业爆发到萎靡的时代。说实话这几年的从业经历彻底打翻了我对游戏行业的认知，甚至对人性有了更加深刻的领悟。</p><p>以技术专家加入游戏行业，再后来的运营，商务多重角色的转换让我看清了互联网行业本来的面目，也让我看清了整个游戏的行业的生存之道。我感谢这几年的历练，也感谢我自己对陌生领域始终充满了好奇心。即便到现在我仍旧保持一颗敬畏之心去探索未知的领域。</p><p>我们这代人因为游戏经历的太多，你能想到什么历史性的事件是与游戏有关的？</p><p>在此感谢我的父亲，在我7岁的时候送我的礼物居然是一台胜天的游戏机。那个时候连彩色电视机都还没有普及的年代，我居然有了游戏机，毫不夸张的说那时候我才是这条街最亮的仔。</p><img src="https://cdn.fanfq.com/picgo/20210812150155.jpeg?imageslim," title="胜天游戏机"><p>我也感谢我的两位朋友，他们分别送了XBOX,PS4. 这两台主机给我。比较可惜的是我真的没有太多的时间去体验这些游戏机。自从成年之后我未曾在游戏方面花太多的时间，也可以说市面的是绝大多数的游戏都没能成功的吸引我，好的游戏我会称赞他，即便如此想让我长时间的玩这款游戏比较难。</p><img src="https://cdn.fanfq.com/picgo/20210812150213.jpeg?imageslim," title="XBOX 360"><img src="https://cdn.fanfq.com/picgo/20210812150223.jpeg?imageslim," title="Play Station 4"><p>我总结了一下，我玩游戏不上瘾，这不是我有较强的自控力，而是我了解游戏的逻辑，我仅仅将游戏当做消费品，消遣时间用的。就和你刷短视频一样，都在消费内容，消遣时间而已。</p><p>人到中年，羁绊也越来越多，工作的烦恼，家庭的琐碎，但凡一个成年人如果有固定时间投身自己的爱好，在我看来是极为奢侈的一件事。</p><p>等新款的Switch发售，我准备入手一台，之所以迟迟不入手的主要原因是那块720p的屏幕。新款的Switch虽然升级成OLED屏幕了，可仍旧是720p的。比较可惜，但我不想再等了。我想奢侈一把，挤出固定时间好好玩玩游戏，玩玩Switch。</p><img src="https://cdn.fanfq.com/picgo/20210812150251.jpeg?imageslim,Switch" title="OLED"><p>游戏行业背负了本该不该背负的舆论压力，游戏行业的从业者们，且行且珍惜。</p><p>8月3日，新华社旗下经济参考报发表文章，称以《王者荣耀》为代表的网络游戏是“精神鸦片”，会对未成年人的健康成长造成不可估量的影响。不过现在这篇文章也找不到了，你懂的。</p><p>作为曾今的游戏行业从业者来说，目前就全球而言，腾讯是最大的游戏公司，最大游戏发行公司，我甚至连他的财报都不用看，其中游戏的收入占其总收入的50%以上，剩下的就是广告收入。除了广告和游戏收入以外的其他收入基本可以忽略不计。</p><p>我刚入游戏行业的时候，当时最流行的手游是皇室战争，时间不长皇室战争的研发公司supercell就被腾讯收购了。但凡能叫得出来的名字的游戏公司，或多或少的都有腾讯的占股。</p><p>大家是否还记得马云曾今扬言称之“饿死也不做游戏”，但在2017年成立了阿里游戏，游戏行业这块蛋糕太诱惑了。</p><p>做为过来人我只能说游戏行业真的很挣钱，但实际上游戏行业近几年来并不好过。当初我们的合作伙伴还在继续做这行的不多了，都纷纷改行了。游戏版号，类似于图书背面那个条形码的ISBN号。游戏产品想要正式发行现在必须要有版号，以前野蛮生长的时候监管的并不是那么的严格，自从2018年以来能够办到游戏的版号已经不多了，基本都被大厂熔断，就已经卡死了90%的游戏公司。</p><p>这里补充一下，如果游戏是收费的，或者有内购的话现在必须要有版号的。如果是免费的或者是通过广告变现的是不需要版号的。这里是有区别的。</p><p>剩下的就是游戏内容，市面上绝大多数游戏的是换皮游戏。同一款游戏的换一套美术素材，换个名字就是新游戏，类似的情况比比皆是。从苹果App Store历年来整顿可以看出被下架的都是一些换皮的或者违规的游戏类产品。</p><p>作为我而言，是赞成游戏产品监管的。我承认类似 《Addiction by Design》这样的说法，游戏的成瘾性，支付点都是经过精心策划的。我觉得这个也无可厚非，分析用户的心里诱导他们的决策，在从商业行为中无所不在。</p><p>负责任的说市面上任何一款头部的APP，他们的每个按钮，每个颜色，每个字体都是经过精心的设计的。目的就是让用户更多的停留在他们的APP中，更何况市面上不乏那些通过AI分析进行内容精准推荐的APP。</p><p>至于《王者荣耀》是否真的是“精神鸦片”不是简单的一篇文章就能定性的，也不是我所关注的内容。我希望能够提出有效的解决方案，而不是一棍子打死。我们成年人也不希望和自己打游戏的队友是小学生，通过游戏的分级制度，实名认证，支付通道，在线时长等等多维度的疏导，建立一个有序的健康的游戏环境才是出发点。</p><p>一棍子打死了，没有游戏，还有打牌，斗蛐蛐，斗鸡。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="blog_" scheme="https://blog.fanfq.com/categories/blog/"/>
    
    
      <category term="blog_" scheme="https://blog.fanfq.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>播客录制技巧软件篇audacity基础配置</title>
    <link href="https://blog.fanfq.com/podcast/%E6%92%AD%E5%AE%A2%E5%BD%95%E5%88%B6%E6%8A%80%E5%B7%A7%E8%BD%AF%E4%BB%B6%E7%AF%87audacity%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE.html"/>
    <id>https://blog.fanfq.com/podcast/播客录制技巧软件篇audacity基础配置.html</id>
    <published>2021-07-29T06:57:32.000Z</published>
    <updated>2021-07-29T08:05:38.078Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>以我的经验，尽量在录制前就做好准备，尽可能的确保录制出来的音频质量的可靠的，避免过多的后期处理。<br>个人感受电容麦克风更加适合录制唱歌，或者对声音真的有特别的细腻的要求的。<br>否则选择动圈麦克风是比较明智的选择，家庭环境避免不了环境底噪的如电脑的风扇，<br>空调的声音等，而动圈麦克风比较有效的屏蔽这种底噪。<br>如果想要监听人声以及后期做编辑，推荐使用监听耳机，而一般的hifi耳机并不能真实的还原声音原本的面貌。<br>这里说明一下，如果条件允许尽可能买好一点的音频设备，音频设备相比相机来说是比较保值的而且不容易坏。<br>买好点的设备目的就是为了少走冤枉路 <a href="https://www.elselook.com/about/devices" target="_blank" rel="noopener">我的设备清单</a></p></blockquote><p><a href="https://www.audacityteam.org/" target="_blank" rel="noopener">audacity</a> 是一款免费的开源软件，对比下来这款软件特别适合新手。以下是我经常用到的几个配置。</p><h1 id="降噪"><a href="#降噪" class="headerlink" title="降噪"></a>降噪</h1><p>录制的技巧，首先录制一段环境音然后再开始真正的录制，这段环境音可以作为我们后期降噪时所需采样的素材。<br>通过采样素材对比算法后，软件会自动将段落中类似的波段的音频给消除掉，这也就是降噪所产生的作用。</p><img src="https://cdn.fanfq.com/picgo/20210729154425.png?imageslim"><h1 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h1><p>这个比较重要，特别录制音频质量不好的情况下，比如说话离话筒忽远忽近个波形形成一个个山峰的时候，这个步骤是一定会使用到的。<br>他的作用主要是将高于指定阈值的音量进行压缩<br>通常情况下阈值会设定为-15db（也可以根据波形的实际情况进行调整），比率为2:1<br>那么0db的音量会被压缩成 -15+（15-0）* 1/2 = -7.5 db , 这里要注意一下只有音量大于-15db的时候才会被压缩。</p><img src="https://cdn.fanfq.com/picgo/20210729154454.png?imageslim"><h1 id="图形化均衡器"><a href="#图形化均衡器" class="headerlink" title="图形化均衡器"></a>图形化均衡器</h1><p>这个比较个性化的调整，主要用于调整声音的频率的。通常我不调。</p><img src="https://cdn.fanfq.com/picgo/20210729154528.png?imageslim"><h1 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h1><p>这个是很重要的一件事，一定要做的。<br>因为经过以上的操作，声音的音量必然会受到影响，我知道的是很多平台会二次压缩的统一响度的，但绝大多数平台是直出的。出现的症状就是别人听你的节目会觉得声音小或者大，听感很不舒服。</p><img src="https://cdn.fanfq.com/picgo/20210729154620.png?imageslim">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="podcast" scheme="https://blog.fanfq.com/categories/podcast/"/>
    
    
      <category term="podcast" scheme="https://blog.fanfq.com/tags/podcast/"/>
    
  </entry>
  
  <entry>
    <title>VirtualBox安装Ubuntu Linux常用配置</title>
    <link href="https://blog.fanfq.com/dev/VirtualBox%E5%AE%89%E8%A3%85Ubuntu_Linux%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE.html"/>
    <id>https://blog.fanfq.com/dev/VirtualBox安装Ubuntu_Linux常用配置.html</id>
    <published>2021-03-01T07:37:27.000Z</published>
    <updated>2021-03-02T06:27:42.110Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p>个人习惯使用<code>桥接模式</code>也推荐这个模式，DHCP会独立分发一个IP给虚拟机LAN中可当做独立主机使用，缺点就是会占用一个IP不过这点在本地开发中可以忽略毕竟内网通常是不会缺IP资源的。</p><p><strong>注意</strong> 这里需要注意下，我这里 <code>en0:以太网</code> 是指通过网线来模拟虚拟机的网卡端口，也就是说宿主机需要连接网线。如果是无线网卡的话则是 <code>en1:Wi-Fi(AirPort)</code> 这里需要注意一下，特别是针对基于RJ45接口的笔记本而言。</p><img src="https://cdn.fanfq.com/picgo/20210301154148.png?imageslim"><h3 id="共享目录"><a href="#共享目录" class="headerlink" title="共享目录"></a>共享目录</h3><p>顾名思义就是在宿主机上创建一个目录，方便于虚拟机随时的访问，以便于宿主机与虚拟机文件之间的拷贝。</p><ol><li><p>在宿主机创建共享的位置，比如我这里是 <code>/User/fanfq/VirtualBox VMs/macshare</code></p></li><li><p>配置共享目录 </p></li></ol><img src="https://cdn.fanfq.com/picgo/20210301155815.png?imageslim"><ol start="3"><li>配置虚拟机，需要注意的一下这里需要安装vbox的增强插件，直接在虚拟机中点击菜单栏的<code>devices</code> &gt; <code>Insert Guest Additions CD image</code> 点击安装即可</li></ol><img src="https://cdn.fanfq.com/picgo/20210301153505.png?imageslim"><ol start="4"><li><p>重启测试，此时在进入系统就会看在根目录看到 <code>/macshare</code> 目录，此时在此目录下写入文件，在宿主机 <code>/User/fanfq/VirtualBox VMs/macshare</code> 会实时同步，反之亦可。</p></li><li><p>手动挂载共享目录，如果第4步不成功可能需要手动挂载</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t vboxsf macshare /macshare</span><br></pre></td></tr></table></figure><h3 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h3><p>默认情况下ubuntu是没有安装 <code>ssh</code> 服务器端的，为了方便客户端的连接需要自己手动安装一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="dev" scheme="https://blog.fanfq.com/categories/dev/"/>
    
    
      <category term="dev" scheme="https://blog.fanfq.com/tags/dev/"/>
    
      <category term="运维" scheme="https://blog.fanfq.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Maven工程引用jar包</title>
    <link href="https://blog.fanfq.com/dev/Maven%E5%B7%A5%E7%A8%8B%E5%BC%95%E7%94%A8jar%E5%8C%85.html"/>
    <id>https://blog.fanfq.com/dev/Maven工程引用jar包.html</id>
    <published>2021-02-07T03:54:54.000Z</published>
    <updated>2021-02-07T08:24:27.073Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近期项目需要研究了下京东SDK，发现其提供了SDK jar包。自从用了mvn进行包管理，应该是这几年都很少去引用jar了。</p><p>为此整理一下如何在maven工程引用jar包。</p><h3 id="将jar包加入本地仓库"><a href="#将jar包加入本地仓库" class="headerlink" title="将jar包加入本地仓库"></a>将jar包加入本地仓库</h3><p>按照个人习惯先备个shell脚本，方便使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file \</span><br><span class="line">-Dfile=open-api-sdk-2.0-2021-02-06.jar \</span><br><span class="line">-DgroupId=com.jd.open.api \</span><br><span class="line">-DartifactId=jd-open-api \</span><br><span class="line">-Dversion=2.0 \</span><br><span class="line">-Dpackaging=jar</span><br></pre></td></tr></table></figure><p>其中：<code>-DgroupId</code>，<code>-DartifactId</code> 的作用是指定了这个jar包在repository的安装路径，只是用来告诉项目去这个路径下寻找这个名称的jar包。</p><p>如果本地仓库被清楚或者部署到新的机器上都需要安装一下。</p><p>安装结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] ------------------&lt; org.apache.maven:standalone-pom &gt;-------------------</span><br><span class="line">[INFO] Building Maven Stub Project (No POM) 1</span><br><span class="line">[INFO] --------------------------------[ pom ]---------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- maven-install-plugin:2.4:install-file (default-cli) @ standalone-pom ---</span><br><span class="line">[INFO] Installing /.../app/src/main/resources/libs/open-api-sdk-2.0-2021-02-06.jar to /Users/fred/.m2/repository/com/jd/open/api/jd-open-api/2.0/jd-open-api-2.0.jar</span><br><span class="line">[INFO] Installing /var/folders/m5/n09g6tjx30510drtjpc405m40000gn/T/mvninstall7006216312529085370.pom to /Users/fred/.m2/repository/com/jd/open/api/jd-open-api/2.0/jd-open-api-2.0.pom</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  0.410 s</span><br><span class="line">[INFO] Finished at: 2021-02-07T10:55:00+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h3 id="跟新pom-xml文件"><a href="#跟新pom-xml文件" class="headerlink" title="跟新pom.xml文件"></a>跟新pom.xml文件</h3><p>然后再在项目工程中引用即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.jd.open.api&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;jd-open-api&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>注</strong>为了方便起见，我都会将需要三方jar包都会放在工程目录中以免丢失或者忘记。</p><img src="https://cdn.fanfq.com/picgo/20210207141200.png?imageslim">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="dev" scheme="https://blog.fanfq.com/categories/dev/"/>
    
    
      <category term="mvn" scheme="https://blog.fanfq.com/tags/mvn/"/>
    
  </entry>
  
  <entry>
    <title>js获取浏览器语言</title>
    <link href="https://blog.fanfq.com/dev/js%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%AD%E8%A8%80.html"/>
    <id>https://blog.fanfq.com/dev/js获取浏览器语言.html</id>
    <published>2021-02-04T02:25:38.000Z</published>
    <updated>2021-02-04T02:32:20.093Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var type = navigator.appName;</span><br><span class="line">if (type == &quot;Netscape&quot;)&#123;</span><br><span class="line">  var lang = navigator.language;//获取浏览器配置语言，支持非IE浏览器</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  var lang = navigator.userLanguage;//获取浏览器配置语言，支持IE5+ == navigator.systemLanguage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lang = lang.toLowerCase();</span><br><span class="line">console.log(lang);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var lang_short = lang.substr(0, 2);//获取浏览器配置语言前两位</span><br><span class="line"></span><br><span class="line">if (lang == &quot;zh-cn&quot;)&#123;</span><br><span class="line">  console.log(&quot;简体中文&quot;);</span><br><span class="line">  //alert(lang);</span><br><span class="line">  //window.location.replace(&apos;url&apos;);//中文编码时打开链接</span><br><span class="line">&#125;else if (lang_short == &quot;zh&quot;)&#123;</span><br><span class="line">  console.log(&quot;繁体中文&quot;);</span><br><span class="line">  //window.location.replace(&apos;url&apos;);</span><br><span class="line">&#125;else&#123;//其他语言编码时打开以下链接</span><br><span class="line">  //window.location.replace(&apos;url&apos;);</span><br><span class="line">  console.log(&quot;英语&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文中截取lang的前2位字符，是因为浏览器语言返回值可能是：</p><table><thead><tr><th style="text-align:right">lang</th><th style="text-align:right">name</th></tr></thead><tbody><tr><td style="text-align:right">zh-cn</td><td style="text-align:right">Chinese(PRC)</td></tr><tr><td style="text-align:right">zh-tw</td><td style="text-align:right">Chinese(Taiwan Region)</td></tr><tr><td style="text-align:right">zh-hk</td><td style="text-align:right">Chinese(Hong Kong SAR, PRC)</td></tr><tr><td style="text-align:right">zh-sg</td><td style="text-align:right">Chinese(Singapore)</td></tr><tr><td style="text-align:right">en-us</td><td style="text-align:right">English(United States)</td></tr><tr><td style="text-align:right">en</td><td style="text-align:right">English</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="dev" scheme="https://blog.fanfq.com/categories/dev/"/>
    
    
      <category term="dev" scheme="https://blog.fanfq.com/tags/dev/"/>
    
      <category term="js" scheme="https://blog.fanfq.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>宝塔面板常用配置纪要</title>
    <link href="https://blog.fanfq.com/dev/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E7%BA%AA%E8%A6%81.html"/>
    <id>https://blog.fanfq.com/dev/宝塔面板常用配置纪要.html</id>
    <published>2020-12-25T08:54:37.000Z</published>
    <updated>2020-12-31T03:33:08.505Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>我个人是使用习惯是使用阿里云自带的 <code>负载均衡SLB</code> 服务，完成 <code>反向代理</code>，<code>负责均衡</code>，<code>SSL证书</code>,<code>域名解析</code> 等操作，同时也推荐在Pord环境中使用，这样在后期在跟新的过程中更加灵活。<br>而在开发测试环境中，单机部署宝塔面板，可通过<code>Ngix</code>的配置完成以上配置。</p><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p><code>eg.以java项目为例，我们部署的到服务器上确保指定端口可访问，如 SERVER_IP:8080</code><br>但实际情况是，我们希望 <code>api.xxx.com</code> 这种域名的情况的下去访问该网站或者接口时，具体操作步骤如下。</p><ol><li><p>域名解析，将 <code>api.xxx.com</code> cname 指向到 SERVER_IP 上，注意这里在没有配置端口号的情况下默认端口为80，通过<code>ping  api.xxx.com</code>验证是否解析成功。</p></li><li><p>在宝塔面包中创建一个静态网站,如下图所示。</p></li></ol><img src="https://cdn.fanfq.com/picgo/20201228093523.png?imageslim"><p>因为我们是java工程，只需要宝塔给我们做一个反向代理的功能，所以并不关注其他的有关php的配置,选择静态部署。</p><ol start="3"><li>反向代理</li></ol><p>配置反向代理将服务请求转发至 <code>SERVER_IP:8080</code></p><img src="https://cdn.fanfq.com/picgo/20201228094451.png?imageslim"><p>好，截止到目前为止，即可通过 <code>api.xxx.com</code> 访问到 <code>SERVER_IP:8080</code> 网站，反向代理的主要功能就是如此，说白了就是做了个端口映射。在此解决一台服务器通过不同的域名解决同一端口的地址映射关系。</p><h4 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h4><p>如果是API服务，并且工程中并没有处理跨域的问题时，又不想通过代码的方式去解决，此时可以通过配置ngix解决此问题。</p><img src="https://cdn.fanfq.com/picgo/20201228095218.png?imageslim"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#解决跨域问题</span><br><span class="line">add_header Access-Control-Allow-Origin *;</span><br><span class="line">add_header Access-Control-Allow-Headers X-Requested-With;</span><br><span class="line">add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br></pre></td></tr></table></figure><h3 id="应用管理器"><a href="#应用管理器" class="headerlink" title="应用管理器"></a>应用管理器</h3><p>这个是宝塔官方出的一个管理工具，具体功能类似的pm2提供守护进程确保服务的稳定性，这也是我最近才开始用的。我使用其的目的主要是为了解决应用程序跟随服务器自启动。</p><ol><li>应用管理器中首先在<code>环境池</code>中创建想要的启动命令，比如下面的java命令</li></ol><img src="https://cdn.fanfq.com/picgo/20201228095757.png?imageslim"><ol start="2"><li>然后再在<code>应用列表</code>中<code>添加应用</code></li></ol><img src="https://cdn.fanfq.com/picgo/20201228100154.png?imageslim"><p>最终其完整的启动命令如下：<br><code>/usr/bin/java -jar /home/fanfq/apps/x.jar --server.port=8180 --downloadPath=/macshare</code></p><p><strong><em>注意</em></strong> 中文乱码问题<br><img src="https://cdn.fanfq.com/picgo/20201231113202.png?imageslim"><br><code>/usr/bin/java -Dfile.encoding=UTF-8 -jar /home/fanfq/apps/x.jar --server.port=8180 --downloadPath=/macshare</code></p><p>如果启用了<code>进程守护</code>那么此时可以通过各种方式停止服务，然后再观察该服务是否正常重启。这就是<code>进程守护</code>的意义，btw我们经常所见的mysqld实际上就是mysql服务的守护进程，通常用后缀d命名。</p><h3 id="webhook"><a href="#webhook" class="headerlink" title="webhook"></a>webhook</h3><p>这个功能也是常规用的比较多的应用，我的应用场景是当git仓库有新的push时会发送一个http请求给服务器，此时服务器会自动pull到最新版本，并自动完成编译，重启等操作。<br>此功能是比较简易话的完成自动构建的操作，在开发测试环境中特别适用。</p><ol><li>创建webhook，编辑执行脚本<img src="https://cdn.fanfq.com/picgo/20201228101333.png?imageslim"></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br><span class="line">sh /root/xxx/bin/autobuild.sh</span><br><span class="line"></span><br><span class="line">time=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line">echo &quot;----latest build time $&#123;time&#125;&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过查看秘钥获取请求的地址<img src="https://cdn.fanfq.com/picgo/20201228101431.png?imageslim"></li></ol><p>后续只要接口地址获取到请求，即触发脚本执行。</p><p><strong><em>注意</em></strong> </p><ol><li>请求接口要求外网可访问，所以说这台服务器要有公网ip，确保可访问。</li><li>脚本执行的权限问题，通过日志的方式查看脚本的执行是否成功。如果出现日志不如预期则可能是执行过程中出现权限等问题。需要自己测试排查如权限，环境变量等。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="dev" scheme="https://blog.fanfq.com/categories/dev/"/>
    
    
      <category term="dev" scheme="https://blog.fanfq.com/tags/dev/"/>
    
      <category term="运维" scheme="https://blog.fanfq.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Telegram Bot 开发初体验,抖音去水印下载机器人实践</title>
    <link href="https://blog.fanfq.com/dev/Telegram_bot_dev_thinking.html"/>
    <id>https://blog.fanfq.com/dev/Telegram_bot_dev_thinking.html</id>
    <published>2020-12-24T05:56:34.000Z</published>
    <updated>2020-12-25T00:56:07.743Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><img src="https://cdn.fanfq.com/picgo/20201225083005.jpg?imageslim"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>原本是打算用<code>钉钉</code>实现该功能的，一看要做企业认证就放弃的。不得不说这种所谓的认证就拒绝了相当多的独立开发者，这一点绝对是受诟病的。</p><p>前端时间研究下<code>Telegram</code>相关的开发，总体来说实现了想要得所有功能，但是在测试的过程中发现很多问题。主要是因为早期Tg的开放接口被滥用的问题导致的，从而想要实现一些功能是受限的以免接口滥用。</p><p>Telegram Bot 和绝大多数的IM通讯软件中的机器人是一样的，</p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="注册一个机器人，获取token"><a href="#注册一个机器人，获取token" class="headerlink" title="注册一个机器人，获取token"></a>注册一个机器人，获取token</h4><p>直接在Tg中与@BotFather对话即可创建bot,比较有趣的是在Tg很多的交互式体验都是通过类似对话的方式。</p><img src="https://cdn.fanfq.com/picgo/20201225082418.jpg?imageslim"><h4 id="测试token"><a href="#测试token" class="headerlink" title="测试token"></a>测试token</h4><p>将下面的链接的<code>{TOKEN}</code>替换成所获取的token然后浏览器访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.telegram.org/bot&#123;TOKEN&#125;/getUpdates</span><br></pre></td></tr></table></figure><p>返回数据，此时与机器人对话的内容均会在此显示出来</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">ok: true,</span><br><span class="line">result: [ ... ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三方sdk集成"><a href="#三方sdk集成" class="headerlink" title="三方sdk集成"></a>三方sdk集成</h4><p>为了方便开发，已经有很成熟的三方sdk了。这里推荐 <a href="https://github.com/rubenlagus/TelegramBots/wiki/Getting-Started" target="_blank" rel="noopener">TelegramBots</a></p><h3 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h3><p>趁此机会和大家介绍一下我做的机器人，其主要功能就是通过抖音的分享链接下载其不带水印版本的视频。</p><p>机器人体验地址 <a href="https://t.me/fast_dl_bot" target="_blank" rel="noopener">https://t.me/fast_dl_bot</a></p><img src="https://cdn.fanfq.com/picgo/20201225083459.png?imageslim"><h4 id="抖音去水印原理"><a href="#抖音去水印原理" class="headerlink" title="抖音去水印原理"></a>抖音去水印原理</h4><h5 id="选择想要下载的视频，获取分享链接如下"><a href="#选择想要下载的视频，获取分享链接如下" class="headerlink" title="选择想要下载的视频，获取分享链接如下"></a>选择想要下载的视频，获取分享链接如下</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天是国际篮球日，你能#接住姚明的传球  吗？  https://v.douyin.com/JbUn9qr/ 复制此链接，打开抖音搜索，直接观看视频！</span><br></pre></td></tr></table></figure><h5 id="访问链接，解析出视频源地址，如下"><a href="#访问链接，解析出视频源地址，如下" class="headerlink" title="访问链接，解析出视频源地址，如下"></a>访问链接，解析出视频源地址，如下</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">https://v.douyin.com/JbUn9qr/ </span><br><span class="line"></span><br><span class="line">跳转 -&gt; </span><br><span class="line"></span><br><span class="line">https://www.iesdouyin.com/share/video/6908508376079109390/?region=CN&amp;mid=6908508442169133832&amp;u_code=11ijh199a&amp;titleType=title&amp;did=68226817704&amp;iid=668150976480124&amp;utm_source=copy_link&amp;utm_campaign=client_share&amp;utm_medium=android&amp;app=aweme</span><br><span class="line"></span><br><span class="line">获取视频源地址 -&gt;</span><br><span class="line"></span><br><span class="line">https://aweme.snssdk.com/aweme/v1/playwm/?video_id=v0300f010000bvfv7l99jbbabl28o260&amp;ratio=720p&amp;line=0</span><br></pre></td></tr></table></figure><img src="https://cdn.fanfq.com/picgo/20201225083829.png?imageslim"><h5 id="修改视频源地址，去掉视频源地址中的wm即可得到不带水印的地址源。"><a href="#修改视频源地址，去掉视频源地址中的wm即可得到不带水印的地址源。" class="headerlink" title="修改视频源地址，去掉视频源地址中的wm即可得到不带水印的地址源。"></a>修改视频源地址，去掉视频源地址中的<code>wm</code>即可得到不带水印的地址源。</h5><p>并通 agent 为手机客户端访问改地址，即可获取到不带水印的视频。<br>然后下载视频即可得到不带水印的视频</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://aweme.snssdk.com/aweme/v1/play/?video_id=v0300f010000bvfv7l99jbbabl28o260&amp;ratio=720p&amp;line=0</span><br></pre></td></tr></table></figure><img src="https://cdn.fanfq.com/picgo/20201225083828.png?imageslim"><h4 id="Telegram-Bot-实现"><a href="#Telegram-Bot-实现" class="headerlink" title="Telegram Bot 实现"></a>Telegram Bot 实现</h4><p>采用 <code>TelegramBots</code> 实现，涉及三方软件可能会有争议，既不提供代码实现，本文仅分析原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAmazingBot</span> <span class="keyword">extends</span> <span class="title">TelegramLongPollingBot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpdateReceived</span><span class="params">(Update update)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//1.基础数据获取与处理</span></span><br><span class="line">       String username = update.getMessage().getChat().getUserName();</span><br><span class="line">       String text = update.getMessage().getText(); </span><br><span class="line"></span><br><span class="line">       <span class="comment">//2.通过正则判断text是否包含url等等其它验证</span></span><br><span class="line">       <span class="comment">//3.通过url获取不带水印的下载链接</span></span><br><span class="line">       <span class="comment">//4.通过下载链接获取输入流</span></span><br><span class="line">       <span class="comment">//以上2，3，4涉及三方软件可能会有争议，既不提供代码实现，本文仅分析原理。</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//4.将输入流直接返回给发送者</span></span><br><span class="line">       InputFile inputFile = <span class="keyword">new</span> InputFile(inputStream,System.currentTimeMillis()+<span class="string">".mp4"</span>);</span><br><span class="line">       SendVideo video = <span class="keyword">new</span> SendVideo();</span><br><span class="line">       video.setVideo(inputFile);</span><br><span class="line">       video.setChatId(update.getMessage().getChatId().toString());</span><br><span class="line">       execute(video);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBotUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"fast_dl_bot"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBotToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"1434***IaQ4w5iJTGCRDtMSUVY"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="dev" scheme="https://blog.fanfq.com/categories/dev/"/>
    
    
      <category term="dev" scheme="https://blog.fanfq.com/tags/dev/"/>
    
      <category term="Telegram" scheme="https://blog.fanfq.com/tags/Telegram/"/>
    
  </entry>
  
  <entry>
    <title>似乎应该调整一下工作流，让时间更有效率</title>
    <link href="https://blog.fanfq.com/blog_/%E4%BC%BC%E4%B9%8E%E5%BA%94%E8%AF%A5%E8%B0%83%E6%95%B4%E4%B8%80%E4%B8%8B%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%AE%A9%E6%97%B6%E9%97%B4%E6%9B%B4%E6%9C%89%E6%95%88%E7%8E%87.html"/>
    <id>https://blog.fanfq.com/blog_/似乎应该调整一下工作流让时间更有效率.html</id>
    <published>2020-11-16T03:58:57.000Z</published>
    <updated>2020-11-25T03:01:54.549Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原本我以为我可以在周末的时间写出稿件，但实践证明这个太难了，我计算了一下仅仅周六上午半天的时间我给小朋友擦屁股累积超过10次以上，更多是中途的捣乱，姐姐有点粘我总是习惯性的试图在我工作的过程中坐到我的腿上，和我一起看着电脑屏幕，我和妻子都一致的观念在我们的家庭教育中尽可能的让小朋友减少对显示器的依赖。所以此时我不得不放下手头上的工作去陪伴她们。</p><p>我们家是绝对杜绝小朋友玩手机，平板电脑的，即便是电视每周只可以限制性的看一个小时，而我现在逐步的下载一些优质的动画电影陪伴她们一起收看。妹妹更喜欢“天猫精灵”因为更方便通过语音交互的方式切换她想收听的内容，常常早晨起来她独自一人坐在客厅听着天猫精灵里播放出来的故事。而姐姐视乎缺乏耐心基本不会长时间做在那里收听节目，即便是看电视她也会因为其他的事情中断她的观看兴趣。</p><p>这两人的性格，差别太大了。</p><p>所以，我可能要尝试调整一下我的工作流，让时间更加的效率。周末的时间更多的是陪伴小朋友，见证他们成长更多的是陪伴。实际上养娃的过程中琐碎的事情特别多，每当看到她们睡着的样子就特别的温馨。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="blog_" scheme="https://blog.fanfq.com/categories/blog/"/>
    
    
      <category term="blog_" scheme="https://blog.fanfq.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>花了两天的时间终于把Podcast发布站搭建好了</title>
    <link href="https://blog.fanfq.com/podcast/%E8%8A%B1%E4%BA%86%E4%B8%A4%E5%A4%A9%E7%9A%84%E6%97%B6%E9%97%B4%E7%BB%88%E4%BA%8E%E6%8A%8APodcast%E5%8F%91%E5%B8%83%E7%AB%99%E6%90%AD%E5%BB%BA%E5%A5%BD%E4%BA%86.html"/>
    <id>https://blog.fanfq.com/podcast/花了两天的时间终于把Podcast发布站搭建好了.html</id>
    <published>2020-11-04T08:25:28.000Z</published>
    <updated>2020-11-19T07:18:36.304Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这篇文章主要是要将的我工作流给记录下来，以免以后时间长了忘记了。</p><p><a href="http://fm.fanfq.com" target="_blank" rel="noopener">http://fm.fanfq.com</a> 这个站实际上是我的podcast发布站，采用<code>hexo</code>+<code>next主题</code>+<code>podcasts插件</code>,放在<code>github</code>上托管，mp3等资源文件放在<a href="!https://portal.qiniu.com/signup?code=1h449nnsixj6a">七牛CDN</a>上托管。</p><p>实际上没有什么，主要是说下这个podcasts插件并不好用，我自己根据实际需求做了修改，以及增加了一个脚本获取mp3文件的数据。</p><p>podcasts插件主要是为了生成符合apple podcast rss feed 文件，貌似国外的主流的都是以rss订阅的方式发布的，这很好，不需要作者每个平台手动的发布，我这里的发布站也是为了解决这个问题。</p><p>有关podcasts插件修改内容看这个链接：(这要比较重要，一定要验证成功才有用)<br><a href="https://github.com/fanfq/hexo-generator-podcasts" target="_blank" rel="noopener">https://github.com/fanfq/hexo-generator-podcasts</a></p><p>还写了python脚本为了获取mp3的参数：<br><a href="https://github.com/fanfq/python-learning/blob/master/src/util/file/mp3_file_rename.py" target="_blank" rel="noopener">https://github.com/fanfq/python-learning/blob/master/src/util/file/mp3_file_rename.py</a></p><p><code>mp3_file_name.py</code>这个脚本，目的是为了重命名文件。如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用于podcast音频文件整理</span><br><span class="line">源文件：003.mp3</span><br><span class="line">重命名后的文件：fm003_8776581_2192.mp3</span><br><span class="line">文件命名规范：fm|003|_length_duration</span><br><span class="line">prefix:文件前缀</span><br><span class="line">003：文件原名</span><br><span class="line">length：文件体积单位byte</span><br><span class="line">duration：文件播放时长单位s</span><br></pre></td></tr></table></figure><p>然后就是写文章了，目前这个文章的结构是需要手动维护的，文章结构示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;#4.整装待发扬帆起航，拒绝消费主义&quot;  #文章标题</span><br><span class="line">category: podcast #固定值</span><br><span class="line">media: https://dl.fanfq.com/fm.fanfq.com/fm004_11922309_496.mp3 #固定值，建议放CDN </span><br><span class="line">image: https://dl.fanfq.com/fm.fanfq.com/fred_1024x1024_fm.jpg   #固定值，建议放CDN </span><br><span class="line">duration: 496  #mp3文件播放时长，这里单位是秒</span><br><span class="line">type: audio/mpeg #固定值</span><br><span class="line">length: 11922309  #mp3文件的字节数，右键文件查看所占磁盘空间</span><br><span class="line">layout: podcast  #固定值</span><br><span class="line">date: 2020-11-03 21:21:57 #创建时间</span><br><span class="line">tags: [播客,消费主义] #文章标签</span><br><span class="line">urlname: vol4 #比如我这里最终文章的链接是 https://fm.fanfq.com/vol4.html</span><br><span class="line">description: 轻奢，小资，精致，这些词是不是听起来有点耳熟?在我看来这些词都是消费主义的簇拥者自己创造出来的文化，通过这种方式给消费者洗脑最终促使消费者买单。 #这个描述，为了填充feed用而不是正文</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">文章正文...</span><br></pre></td></tr></table></figure><p>编辑好后直接发布到github上就可以了，然后等苹果的服务器自动同步。</p><h2 id="总结一下的，流程是"><a href="#总结一下的，流程是" class="headerlink" title="总结一下的，流程是"></a>总结一下的，流程是</h2><p>1.编辑好的mp3文件发到mp3目录下<br>2.执行mp3目录下的 <code>mp3_file_name.py</code> 脚本，自动重命名以及上传到CDN<br>4.创建新的文档 <code>hexo new post NAME</code><br>5.编辑 <code>NAME.md</code> 文件信息<br>6.<code>hexo s</code> 本地预览一下，看是否都正常，只要mp3能正常播放那问题不大<br>7.<code>hexo clean</code>, <code>hexo g</code>,<code>hexo deploy</code> 全套。</p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="https://cdn.fanfq.com/picgo/20201119151421.png?imageslim" class="full-image" alt="工作流"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="podcast" scheme="https://blog.fanfq.com/categories/podcast/"/>
    
    
      <category term="架构" scheme="https://blog.fanfq.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="工作流" scheme="https://blog.fanfq.com/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    
      <category term="podcast" scheme="https://blog.fanfq.com/tags/podcast/"/>
    
  </entry>
  
  <entry>
    <title>网络游戏通讯(WebSocket/Socket)数据加密最佳实践</title>
    <link href="https://blog.fanfq.com/%E6%9E%B6%E6%9E%84/websocket_network_encryption_security_protocol_the_best_practices.html"/>
    <id>https://blog.fanfq.com/架构/websocket_network_encryption_security_protocol_the_best_practices.html</id>
    <published>2020-08-04T10:12:50.000Z</published>
    <updated>2020-09-08T02:47:17.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话:"></a>写在前面的话:</h3><p>之前一篇文章<a href="https://blog.fanfq.com/架构/netty_protobuf_best_practices">《Creator WebSocket Protobuf整合之保姆级全攻略》</a>大概的介绍了下有关protobuf的整合，首先我们认清一点protobuf仅仅是数据封装的模式，并没有加密功能，简单的来说将其理解成增强型json，以便于理解。</p><p>近期也看了一些服务器端的源码，总的来说protobuf算是比较主流的，老点的项目有用json的或者是body是json然后用LengthField加头的。不管如何我个人还是建议使用protobuf，其优势不再赘述了。</p><p>在阅读源码期间，偶然发现baidu的开源项目 [jprotobuf] (<a href="https://github.com/jhunters/jprotobuf" target="_blank" rel="noopener">https://github.com/jhunters/jprotobuf</a>) ，其主要的优势就是不需要再编写.proto的文件的直接在pojo类上加上注解即可，一定程度的简化了我们开发的流程提高的开发效率。但我个人观点还是需要.proto文件的，即便没有此文件也需要通过文档的形式列出所有通讯消息的结构体。随时时间的推移项目的迭代以及各种跨平台的客户端的开发，有一份清晰的文档往往事半功倍，这也算是我个人的偏执吧。</p><a id="more"></a><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/uploads/msg.png" class="full-image" alt="结合本文自定义消息" title="结合本文自定义消息"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="本文重点："><a href="#本文重点：" class="headerlink" title="本文重点："></a>本文重点：</h3><p>websocket/socket网路通讯主流的加密方式，适用于各种应用包括游戏。<br>数据的加密解密必然会带来额外的开销，至于是否采用加密取决于数据的敏感性，如果涉及用户隐私，如个人信息，交易记录等信息还是有必要的。</p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><img src="/uploads/times.png"><h3 id="流程解释"><a href="#流程解释" class="headerlink" title="流程解释"></a>流程解释</h3><p>1.客户端创建连接（建立websocket/socket通讯），申请AES密钥。</p><p>1).当连接创建成功后客户端所发出去的第一个包是通过RSA公钥加密的，其目的就是为了和服务器端申请后续通讯所使用的AES密钥。</p><p>2.而服务器当收到客户端的请求AES密钥的请求包时</p><p>1).通过RSA私钥解密请求包，并验证消息</p><p>2).为本次连接临时生成一个AES密钥(缓存在服务器端)并返回给客户端。也就是说AES密钥每次都会变的，而不是一个固定的值。</p><p>3.客户端获取AES密钥并缓存，好了此时针对本次的连接,客户端/服务器端均有AES密钥，</p><p>那么后续的通讯数据均通过这个AES密钥进行加密解密。</p><p>*截止到这里整个通讯的加密解密过程就说完了，整理清楚了通讯流程下面的工作就会轻松许多。上面有一些关键词需要稍微了解一下，如不清楚请自行百度。以下规范一下加密算法的各项参数，具体的视项目情况而定。</p><h3 id="规范约定"><a href="#规范约定" class="headerlink" title="规范约定"></a>规范约定</h3><p>1.RSA,密钥长度1024, 填充方式PKCS1,公钥加密，私钥解密，公钥可通过私钥生成</p><p>2.AES使用AES/ECB/PKCS7Padding</p><h4 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h4><p>RSA加密规则:若密钥位数是key_size, 单次加密串的最大长度为 (key_size)/8 - 11, 目前位数1024, 则最大加密长度为117，为了方便这里我们选择一次加密长度为100</p><p>将明文数据分成一个或数个最长100字节的小段进行加密，拼接分段加密数据即为最终的Body加密数据</p><h4 id="RSA解密"><a href="#RSA解密" class="headerlink" title="RSA解密"></a>RSA解密</h4><p>RSA解密同样遵循分段规则，对于1024位密钥, 每小段待解密数据长度为128字节</p><p>将密文数据分成一个或数个128字节长的小段进行解密，拼接分段解密数据即为最终的Body解密数据</p><h4 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h4><p>AES加密要求源数据长度必须是16的整数倍, 故需补‘0’对齐后再加密，记录modlen为源数据长度与16取模值</p><p>因加密前有可能对源数据作修改， 故需在加密后的数据尾再增加一个16字节的填充数据块，其最后一个字节赋modlen, 其余字节赋值‘0’， 将加密数据和额外的填充数据块拼接作为最终要发送协议的body数据</p><h4 id="AES解密"><a href="#AES解密" class="headerlink" title="AES解密"></a>AES解密</h4><p>协议body数据, 先将最后一个字节取出，记录modlen， 然后将body截掉尾部16字节填充数据块后再解密（与加密填充额外数据块逻辑对应）</p><p>modlen 为0时，上述解密后的数据即为协议返回的body数据, 否则需截掉尾部(16 - 录modlen)长度的用于填充对齐的数据</p><p>本文演示代码：<a href="https://github.com/fanfq/jprotobuf_sample" target="_blank" rel="noopener">https://github.com/fanfq/jprotobuf_sample</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话:&quot;&gt;&lt;/a&gt;写在前面的话:&lt;/h3&gt;&lt;p&gt;之前一篇文章&lt;a href=&quot;https://blog.fanfq.com/架构/netty_protobuf_best_practices&quot;&gt;《Creator WebSocket Protobuf整合之保姆级全攻略》&lt;/a&gt;大概的介绍了下有关protobuf的整合，首先我们认清一点protobuf仅仅是数据封装的模式，并没有加密功能，简单的来说将其理解成增强型json，以便于理解。&lt;/p&gt;
&lt;p&gt;近期也看了一些服务器端的源码，总的来说protobuf算是比较主流的，老点的项目有用json的或者是body是json然后用LengthField加头的。不管如何我个人还是建议使用protobuf，其优势不再赘述了。&lt;/p&gt;
&lt;p&gt;在阅读源码期间，偶然发现baidu的开源项目 [jprotobuf] (&lt;a href=&quot;https://github.com/jhunters/jprotobuf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/jhunters/jprotobuf&lt;/a&gt;) ，其主要的优势就是不需要再编写.proto的文件的直接在pojo类上加上注解即可，一定程度的简化了我们开发的流程提高的开发效率。但我个人观点还是需要.proto文件的，即便没有此文件也需要通过文档的形式列出所有通讯消息的结构体。随时时间的推移项目的迭代以及各种跨平台的客户端的开发，有一份清晰的文档往往事半功倍，这也算是我个人的偏执吧。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="https://blog.fanfq.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="https://blog.fanfq.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="design" scheme="https://blog.fanfq.com/tags/design/"/>
    
      <category term="netty" scheme="https://blog.fanfq.com/tags/netty/"/>
    
      <category term="protobuf" scheme="https://blog.fanfq.com/tags/protobuf/"/>
    
      <category term="creator" scheme="https://blog.fanfq.com/tags/creator/"/>
    
  </entry>
  
  <entry>
    <title>Cocos Creator WebSocket Protobuf整合之保姆级全攻略</title>
    <link href="https://blog.fanfq.com/%E6%9E%B6%E6%9E%84/netty_protobuf_best_practices.html"/>
    <id>https://blog.fanfq.com/架构/netty_protobuf_best_practices.html</id>
    <published>2020-03-18T10:12:50.000Z</published>
    <updated>2020-09-08T02:29:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>环境说明：<br>Cocos Creator : 2.3.0 学习的速度赶不上它更新的速度<br>protobuf3 <a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/</a><br>protobufjs @6.8.9 <a href="https://github.com/protobufjs/protobuf.js" target="_blank" rel="noopener">https://github.com/protobufjs/protobuf.js</a><br>没错，这是目前最新版本。网上一大堆都是老的 v5 版本，对我来说太low。哈哈实际上我仅仅是为了用那该死的 pbts 啦！</p><p>服务器端：<br>websocket + protobuf3 这里就不具体展开说明了，因为此时我对服务器端没有什么兴趣。</p><img src="/uploads/google_protobuf.png"><h3 id="why-google-protobuf"><a href="#why-google-protobuf" class="headerlink" title="why google protobuf?"></a>why google protobuf?</h3><p>我来告诉你，为什么选择protobuf作为网络的封装协议而为什么不用json？</p><p>1.首先我是google的粉丝<br>2.序列化与反序列化效率高于json，相比而言降低了客户端服务器的资源<br>3.传输体积小，对应的降低的数据流量<br>4.数据类型跨平台，这点很重要。也许你不在乎，等你做多客户端的时候就知道了。<br>5.一定程度脱敏，强调一下protobuf没有加密功能，仅仅是二进制难以阅读而已。本文不涉及加密的操作，先给留个坑如果读者有兴趣我会考虑做篇有关RSA,AES加密封装.</p><a id="more"></a><h3 id="protobuf-结构体定义"><a href="#protobuf-结构体定义" class="headerlink" title="protobuf 结构体定义"></a>protobuf 结构体定义</h3><p>1.通常项目早期的时候已经规定好了通讯协议，下面这个协议属于”<strong>万金油</strong>“适用于绝大多数项目，也是我之前做的项目中所采用的协议。</p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/uploads/protobuf_struct.png" class="full-image" alt="消息结构体封装协议" title="消息结构体封装协议"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>2.通常我还会做一份文档出来，以供其他参与开发的小伙伴使用，类似于这样的</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:center">位数</th><th style="text-align:right">字节数</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td style="text-align:left">nHeaderFlag</td><td style="text-align:center">8*4</td><td style="text-align:right">2</td><td style="text-align:right">包头起始标志，固定为“FC”</td></tr><tr><td style="text-align:left">nProtoID</td><td style="text-align:center">8*4</td><td style="text-align:right">4</td><td style="text-align:right">协议ID</td></tr><tr><td style="text-align:left">nProtoFmtType</td><td style="text-align:center">8*4</td><td style="text-align:right">4</td><td style="text-align:right">协议格式类型，0为Protobuf格式，1为Json格式，目前仅支持 0</td></tr><tr><td style="text-align:left">nProtoVer</td><td style="text-align:center">8*4</td><td style="text-align:right">4</td><td style="text-align:right">协议版本，用于迭代兼容, 目前填0</td></tr><tr><td style="text-align:left">nSerialNo</td><td style="text-align:center">8*8</td><td style="text-align:right">8</td><td style="text-align:right">包序列号，用于对应请求包和回包, 要求递增</td></tr><tr><td style="text-align:left">nBodyLen</td><td style="text-align:center">8*4</td><td style="text-align:right">4</td><td style="text-align:right">包体长度</td></tr><tr><td style="text-align:left">arrBodySHA1</td><td style="text-align:center">8*40</td><td style="text-align:right">40</td><td style="text-align:right">包体原始数据(解密后)的SHA1哈希值</td></tr><tr><td style="text-align:left">arrReserved</td><td style="text-align:center">8*20</td><td style="text-align:right">20</td><td style="text-align:right">保留20字节扩展</td></tr></tbody></table><p>（具体描述封装协议各字段说明）</p><table><thead><tr><th style="text-align:left">分类</th><th style="text-align:center">协议ID</th><th style="text-align:right">Protobuf文件</th><th style="text-align:right">C2S</th><th style="text-align:right">S2C</th><th style="text-align:right">说明 </th></tr></thead><tbody><tr><td style="text-align:left"> 1</td><td style="text-align:center">1001</td><td style="text-align:right"><a href="https://github.com/fanfq/springboot_netty_websocket_protobuffer/blob/master/common/src/main/java/com/fc/common/socket/protobuf/KeepAliveMsg.proto" target="_blank" rel="noopener">KeepAliveMsg</a></td><td style="text-align:right">ping</td><td style="text-align:right">-</td><td style="text-align:right">心跳</td></tr><tr><td style="text-align:left"> 1</td><td style="text-align:center">1901</td><td style="text-align:right"><a href="https://github.com/fanfq/springboot_netty_websocket_protobuffer/blob/master/common/src/main/java/com/fc/common/socket/protobuf/KeepAliveMsg.proto" target="_blank" rel="noopener">KeepAliveMsg</a></td><td style="text-align:right">-</td><td style="text-align:right">pong</td><td style="text-align:right">心跳</td></tr></tbody></table><p>（原生的.proto 文件说明，以便维护）</p><p>3.以KeepAliveMsg.proto为例说明</p><p>ProtoID.proto 一个公用的枚举类型以便管理协议编号<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax =<span class="string">"proto3"</span>;</span><br><span class="line"><span class="comment">//消息头</span></span><br><span class="line"><span class="keyword">enum</span> MsgType&#123;</span><br><span class="line">    DEF = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//keepalive</span></span><br><span class="line">    PING = <span class="number">1001</span>;</span><br><span class="line">    PONG = <span class="number">1901</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>KeepAliveMsg.proto 心跳包协议体<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">syntax =<span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line">message C2S</span><br><span class="line">&#123;</span><br><span class="line">    int64 timestamp = <span class="number">1</span>; <span class="comment">//时间戳</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message S2C</span><br><span class="line">&#123;</span><br><span class="line">    int64 timestamp = <span class="number">1</span>; <span class="comment">//时间戳</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message C2SMsg  <span class="comment">//Request</span></span><br><span class="line">&#123;</span><br><span class="line">    C2S c2s = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message S2CMsg  <span class="comment">//Response</span></span><br><span class="line">&#123;</span><br><span class="line">    int32 code = <span class="number">1</span>;</span><br><span class="line">    string msg = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    S2C s2c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="creator-整合-protobufjs"><a href="#creator-整合-protobufjs" class="headerlink" title="creator 整合 protobufjs"></a>creator 整合 protobufjs</h3><p>好了，截止到这里和我们cocos creator 不相关的东西准备结束了。下面我们来说说creator该做哪些骚操作呢。<br><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/uploads/protobufjs.png" class="full-image" alt="消息结构体封装协议"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></p><p>上面说了google protobuf这里又来个protobuf.js又是什么鬼？</p><p>这个鬼呢，管他什么鬼，我没耐心写了，先将就的写着吧。总之就是在creator中使用protobuf的一个插件针对js, ts 语言环境.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install protobufjs</span><br></pre></td></tr></table></figure><br>安装完成后在安装目录下找到 <code>/Users/fred/node_modules/protobufjs/dist/protobuf.js</code> 将其复制到creator的工程中，然后选择以控件的方式导入。</p><p>同时它主要的目的呢就是将.proto的文件转换成.js（<strong><span class="label danger">pbjs</span></strong>）,以及将其生成出来的.js转换成.d.ts(<strong><span class="label danger">pbts</span></strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pbjs -t <span class="keyword">static</span>-<span class="keyword">module</span> -w commonjs -o compiled.js ProtoID.proto KeepAliveMsg.proto</span><br><span class="line">pbts -o compiled.d.ts compiled.js</span><br></pre></td></tr></table></figure><p>此时我们就生成出了 compiled.d.ts compiled.js 这两个文件，也将其复制到creator工程中，其中修改下compiled.js如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var $protobuf = require("protobufjs/minimal");</span></span><br><span class="line"><span class="keyword">var</span> $protobuf = protobuf;</span><br></pre></td></tr></table></figure></p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/uploads/ccc.png" class="full-image" alt="消息结构体封装协议"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>好，截止到这里。基本上就完成了protobuf的支持的，剩下的工作就是开始怼代码了！</p><p>写到这里，我有点不想写了，以后再更新吧！</p><p>//todo: creator 中如何通过protobuf.js 进行序列化与反序列化，以及自定义头的解析。</p><p>2020-03-18更新</p><p>1.开始各种封装以及代码的调用与实现，大概的介绍下代码清单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-script (项目工程的脚本目录)</span><br><span class="line">    |_ protobuf (存放protobuf相关目录)</span><br><span class="line">        |_compiled.js (pbjs 编译出来的 .js 文件)</span><br><span class="line">        |_compiled.d.ts (pbts 编译出来的 .d.ts 文件)</span><br><span class="line">        |_protobuf.js (导入的插件)</span><br><span class="line">        |_bean (存放封装类相关目录)</span><br><span class="line">            |_FCDecoder.ts  （arraybuf 消息头解码）</span><br><span class="line">            |_FCEncoder.ts  （arraybuf 消息头编码）</span><br><span class="line">            |_FCHeader.ts （封装的消息头对象）</span><br><span class="line">            |_FCMsg.ts （封装的消息对象）</span><br></pre></td></tr></table></figure></p><h3 id="工程示例源码"><a href="#工程示例源码" class="headerlink" title="工程示例源码"></a>工程示例源码</h3><p>以下是工程示例，代码我就不帖了，具体的看工程源码<br><code>https://github.com/fanfq/springboot_netty_websocket_protobuffer</code></p><h3 id="大概的总结一下"><a href="#大概的总结一下" class="headerlink" title="大概的总结一下"></a>大概的总结一下</h3><p>作为初学creator的人来说，creator的生态并没有我想的那么好，总体而言还处于初级阶段，相当一部分大佬是从cocos2dx转过来的，相对而言他们的学习门槛更低更易于上手，就我个人而言特别针对ts语法可能有些地方用不太恰当，不过暂时没有关系，先这么滴。后续慢慢改善，加油！</p><p>有关网络相关的今天是我学习的第三天，基本的网络通讯http,websocket都已经整明白了，而且在native上测试也是通过的。后期再稍微看下有关证书的配置，应该问题不大。</p><p>下面的计划我准备开始学习下UI相关的控件了，之前写了个demo大概的了解下layout，button，label，widget …等基本的控件使用。可能游戏开发中会用到很多的自定义的控件，暂时还没有接触到。</p><p>还有就是基本的物理引擎做个大概的了解，我估计用不到，如果是网游的话碰撞大概率我会写在服务器端。其他的相关的先做个了解的！</p><p>我们又可以愉快的玩耍了！</p><p>一天到晚的，别老想着白嫖！</p><p>老铁要不要关注一下呢？</p><p>写在最后，本人不提供疑难杂症的检查，岁数有点大了，人有点懒了！谢谢！！</p><p>peace&amp;love</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境说明：&lt;br&gt;Cocos Creator : 2.3.0 学习的速度赶不上它更新的速度&lt;br&gt;protobuf3 &lt;a href=&quot;https://developers.google.com/protocol-buffers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developers.google.com/protocol-buffers/&lt;/a&gt;&lt;br&gt;protobufjs @6.8.9 &lt;a href=&quot;https://github.com/protobufjs/protobuf.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/protobufjs/protobuf.js&lt;/a&gt;&lt;br&gt;没错，这是目前最新版本。网上一大堆都是老的 v5 版本，对我来说太low。哈哈实际上我仅仅是为了用那该死的 pbts 啦！&lt;/p&gt;
&lt;p&gt;服务器端：&lt;br&gt;websocket + protobuf3 这里就不具体展开说明了，因为此时我对服务器端没有什么兴趣。&lt;/p&gt;
&lt;img src=&quot;/uploads/google_protobuf.png&quot;&gt;
&lt;h3 id=&quot;why-google-protobuf&quot;&gt;&lt;a href=&quot;#why-google-protobuf&quot; class=&quot;headerlink&quot; title=&quot;why google protobuf?&quot;&gt;&lt;/a&gt;why google protobuf?&lt;/h3&gt;&lt;p&gt;我来告诉你，为什么选择protobuf作为网络的封装协议而为什么不用json？&lt;/p&gt;
&lt;p&gt;1.首先我是google的粉丝&lt;br&gt;2.序列化与反序列化效率高于json，相比而言降低了客户端服务器的资源&lt;br&gt;3.传输体积小，对应的降低的数据流量&lt;br&gt;4.数据类型跨平台，这点很重要。也许你不在乎，等你做多客户端的时候就知道了。&lt;br&gt;5.一定程度脱敏，强调一下protobuf没有加密功能，仅仅是二进制难以阅读而已。本文不涉及加密的操作，先给留个坑如果读者有兴趣我会考虑做篇有关RSA,AES加密封装.&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="https://blog.fanfq.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="https://blog.fanfq.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="design" scheme="https://blog.fanfq.com/tags/design/"/>
    
      <category term="netty" scheme="https://blog.fanfq.com/tags/netty/"/>
    
      <category term="protobuf" scheme="https://blog.fanfq.com/tags/protobuf/"/>
    
      <category term="creator" scheme="https://blog.fanfq.com/tags/creator/"/>
    
  </entry>
  
  <entry>
    <title>基于mongodb信息流数据存储设计</title>
    <link href="https://blog.fanfq.com/mongodb/%E5%9F%BA%E4%BA%8Emongodb%E4%BF%A1%E6%81%AF%E6%B5%81%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1.html"/>
    <id>https://blog.fanfq.com/mongodb/基于mongodb信息流数据存储设计.html</id>
    <published>2018-11-27T04:13:43.000Z</published>
    <updated>2019-08-16T10:06:27.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>以微信朋友圈为例，当打开朋友圈的时候默认刷新最新的数据，数据流以时间倒序排序。那么这样的数据表现形式我们称之为<code>时间线</code>。需要注意的是<br>我们定义时间线的起始时间为账户的创建的时间，例如，A是B的粉丝，B账号创建时间为2018年10月1日，而A账户的创建时间为2018年11月1日则在A的时间线只可以看到2018年11月1日以后的数据。而B的时间线则是2018年10月1日开始往后的数据。也就是说我们以账号的创建时间为锚点。</p><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>用户A是B的粉丝，则A订阅了B，B发布朋友圈则推送给A。</p><img src="/uploads/WX20181120-pubsub.png"><p>如上图所示，我们整理了一下订阅者关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A (3)</span><br><span class="line">-&gt; E</span><br><span class="line">-&gt; F</span><br><span class="line">-&gt; C</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="以空间换时间的存储方案"><a href="#以空间换时间的存储方案" class="headerlink" title="以空间换时间的存储方案"></a>以空间换时间的存储方案</h2><p>写入效率低，数据允余占用存储空间，读取效率高。</p><img src="/uploads/WX20181127-091310.png"><p>首先基于时间线而言，每个用户都有属于自己的一块存储区域，关联数据在写数据时完成。<br>如A发布朋友圈，会将此条记录分别写入 <code>A</code>,<code>E</code>,<code>F</code>,<code>C</code> 的时间线存储区域，每个用户只要获取属于自己的数据即可，相当程度的提高了读取效率。但是此方案将会出现大量的数据允余，这里也就是我们所说的以空间换时间的存储方案，如果此例中A有100万的粉丝，这消息副本需要100万份，即便其中大部分数据从未被读取但是这100万的存储空间是实实在在存在的，而且写数据时也会消耗一定的资源。所以这里也引用的消息序列的方案，将耗时的处理通过队列的方式处理。<br>针对社交关系需要注意一下，<code>E</code>取消对<code>A</code>的关注，只需要将<code>E</code>时间线上的有关<code>A</code>的数据清空掉，同理如果<code>E</code>关注<code>A</code>则需要将<code>A</code>时间线的数据拷贝一份存入<code>E</code>的时间线上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;以微信朋友圈为例，当打开朋友圈的时候默认刷新最新的数据，数据流以时间倒序排序。那么这样的数据表现形式我们称之为&lt;code&gt;时间线&lt;/code&gt;。需要注意的是&lt;br&gt;我们定义时间线的起始时间为账户的创建的时间，例如，A是B的粉丝，B账号创建时间为2018年10月1日，而A账户的创建时间为2018年11月1日则在A的时间线只可以看到2018年11月1日以后的数据。而B的时间线则是2018年10月1日开始往后的数据。也就是说我们以账号的创建时间为锚点。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="https://blog.fanfq.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="https://blog.fanfq.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="mongodb" scheme="https://blog.fanfq.com/tags/mongodb/"/>
    
      <category term="design" scheme="https://blog.fanfq.com/tags/design/"/>
    
  </entry>
  
  <entry>
    <title>基于mongodb用户评论系统数据结构设计</title>
    <link href="https://blog.fanfq.com/mongodb/%E5%9F%BA%E4%BA%8Emongodb%E7%94%A8%E6%88%B7%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1.html"/>
    <id>https://blog.fanfq.com/mongodb/基于mongodb用户评论系统数据结构设计.html</id>
    <published>2018-11-27T04:13:43.000Z</published>
    <updated>2019-08-16T10:06:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>以微信朋友圈为例，但又与微信不同是微信是以强社交为主，只有好友之间才可以查阅对方的朋友圈内容，而我们当前的设计类似的微博以弱社交的表现形式，其显著特点就是即便互相没有关注也可以访问对方的朋友圈数据。所以设计之初首先要确认应用场景是<code>强社交</code>，还是<code>弱社交</code>关系。</p><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>基于timeline的用户留言与点赞</p><img src="/uploads/WX20181127-121621.png"><h3 id="信息流"><a href="#信息流" class="headerlink" title="信息流"></a>信息流</h3><p>注意事项，<code>AREA1</code>,<code>AREA2</code>分别是两块SCHEMA分别存储在mongodb中，本文的重点也是根据实际示例探讨这两块SCHEMA的存储结构。</p><p><code>1</code>. 系统所有的时间均是timestamp long类型，时间间隔24小时之内均显示（xx小时之前），如1小时27分钟前则显示（1小时前）;间隔1小时内则显示（xx分钟前）;不足1分钟则显示（刚刚）。该时间算法由客户端自己完成，服务器端只提供创建时间，默认时区为UTC+8.<br><code>2</code>. 用户显示上报设备型号，则显示该记录。有可能用户上包的设备型号是（oneplus a6000）则显示为（一加 6，或者 oneplus 6）所以设备型号要后台维护。<br><code>3</code>.点赞，延迟3秒与服务器同步，可取消点赞。点赞成功图标高亮显示，不影响数据同步。无人点赞数字区域显示<code>赞</code><br><code>4</code>.留言总数，无人留言显示<code>回复</code><br><code>5</code>.默认值显示3-5条最新的留言记录。支持emoji字符存储。点击<code>4</code>，<code>5</code>则进入留言详细列表</p><h3 id="留言列表"><a href="#留言列表" class="headerlink" title="留言列表"></a>留言列表</h3><p>注意事项，分页显示数据，处理好同步机制。<br><code>A</code>.同<code>1</code><br><code>B</code>.同<code>3</code><br><code>C</code>.这条记录用于张三回复了李四<br><code>D</code>.王五的这条留言被2人点赞其中含当前用户，则高亮显示点赞图标。但无人回复<br><code>E</code>.钱七回复了麻六，则麻六的回复标签上有回复记录的总数。<br><code>F</code>.回复主贴</p><img src="/uploads/WX20181127-121620.png"><p>键盘由点击具体事件后弹出，如先点击<code>1</code>,<code>A</code>,输入框提示回复主体。</p><h3 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h3><p><code>1</code>.直接评论主贴</p><h3 id="回复"><a href="#回复" class="headerlink" title="回复"></a>回复</h3><p><code>A</code>.回复他人留言</p><h2 id="存储方案"><a href="#存储方案" class="headerlink" title="存储方案"></a>存储方案</h2><p>写入效率低，数据允余占用存储空间，读取效率高。</p><h3 id="基于redis"><a href="#基于redis" class="headerlink" title="基于redis"></a>基于redis</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">new post:</span><br><span class="line">&#123;post category&#125;:&#123;author id&#125;:&#123;post id&#125;</span><br><span class="line">朋友圈:123:67890</span><br><span class="line">uid为123的用户发布朋友圈该条记录id为67890</span><br><span class="line"></span><br><span class="line">new reply:</span><br><span class="line">&#123;post category&#125;:&#123;author id&#125;:&#123;post id&#125;:reply:&#123;uid&#125;:&#123;reply post id&#125; </span><br><span class="line">朋友圈:123:67890:reply:852:741052</span><br><span class="line">uid为852的用户回复‘uid为123的用户发布朋友圈id为67890&apos;。该条记录id为741052</span><br><span class="line"></span><br><span class="line">new reply @ user:</span><br><span class="line">&#123;post category&#125;:&#123;uid&#125;:&#123;postid&#125;:replyto:&#123;uid&#125;:to:&#123;uid&#125;:&#123;replyto post id&#125; </span><br><span class="line">朋友圈:123:67890:replyto:852:to:963:7895412</span><br><span class="line">uid为852的用户回复uid为963的用户，在‘uid为123的用户发布朋友圈id为67890&apos;记录下。该条记录id为7895412</span><br><span class="line"></span><br><span class="line">new like base one post:</span><br><span class="line">like:&#123;post id&#125;:&#123;uid&#125;:&#123;like id&#125; 点赞</span><br><span class="line">like:67890:915:731564 </span><br><span class="line">uid为915的用户点赞了postid为67890的文章，该条记录id为731564 </span><br><span class="line"></span><br><span class="line">更多操作</span><br><span class="line"></span><br><span class="line">获取uid为123的所发朋友圈所有内容</span><br><span class="line">朋友圈:123:*</span><br><span class="line"></span><br><span class="line">获取朋友圈文章id为264832的所有点赞记录</span><br><span class="line">like:264832:*</span><br><span class="line"></span><br><span class="line">获取朋友圈文章id为264832的所有回复记录</span><br><span class="line">朋友圈:*:264832:reply* （含用户间的回复）</span><br><span class="line">朋友圈:*:264832:reply:* （不含用户间的回复）</span><br><span class="line">朋友圈:*:264832:replyto:* （仅含用户间的回复）</span><br><span class="line"></span><br><span class="line">获取UID为123朋友圈文章id为264832的所有回复记录</span><br><span class="line">朋友圈:123:264832:reply* （含用户间的回复）</span><br><span class="line">朋友圈:123:264832:reply:* （不含用户间的回复）</span><br><span class="line">朋友圈:123:264832:replyto:* （仅含用户间的回复）</span><br><span class="line"></span><br><span class="line">key-value</span><br><span class="line">AREA 1</span><br><span class="line">article:&#123;uid&#125;:&#123;postid&#125; 发布动态</span><br><span class="line"></span><br><span class="line">AREA 2</span><br><span class="line">article:&#123;uid&#125;:&#123;postid&#125;:reply:&#123;uid&#125;:&#123;postid&#125; 回复主题帖</span><br><span class="line">article:&#123;uid&#125;:&#123;postid&#125;:replyto:&#123;uid&#125;:to:&#123;uid&#125;:&#123;postid&#125; 在这个主题帖下面回复某人</span><br><span class="line"></span><br><span class="line">基于postid点赞</span><br><span class="line">like:&#123;postid&#125;:&#123;uid&#125;:&#123;likeid&#125; 点赞</span><br></pre></td></tr></table></figure><h3 id="基于mongodb"><a href="#基于mongodb" class="headerlink" title="基于mongodb"></a>基于mongodb</h3><img src="/uploads/WX20181128-125100.png"><h2 id="示例详解"><a href="#示例详解" class="headerlink" title="示例详解"></a>示例详解</h2><h4 id="服务器返回数据"><a href="#服务器返回数据" class="headerlink" title="服务器返回数据"></a>服务器返回数据</h4><p>API的设计原则是尽可能的将能一次返回所需要的所有数据，从而减少与服务器间的交互。而我们在存储的时候也不太可能将动态数据直接存储持久化。一旦数据结构改变变动会比较大，从而适当的设计关联关系有助于简化业务逻辑充分的利用mongodb高性能特性。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"category"</span>:<span class="string">"PICTURE"</span>,</span><br><span class="line">   <span class="attr">"content"</span>:<span class="string">"这是一个带9张图片的动态"</span>,</span><br><span class="line">   <span class="attr">"createtime"</span>:<span class="number">1543374370935</span>,</span><br><span class="line">   <span class="attr">"id"</span>:<span class="number">90012</span>,</span><br><span class="line">   <span class="attr">"likeCount"</span>:<span class="number">3</span>,</span><br><span class="line">   <span class="attr">"commentCount"</span>:<span class="number">9</span>,</span><br><span class="line">   <span class="attr">"device"</span>:<span class="string">"红米 6"</span>,</span><br><span class="line">   <span class="attr">"geo"</span>:<span class="literal">null</span>,</span><br><span class="line">   <span class="attr">"author"</span>:&#123;</span><br><span class="line">      <span class="attr">"headImg"</span>:<span class="string">"http://cdnhost/headimg/91d192886a5b9f3e14b6ffa1a674b55d.jpg"</span>,</span><br><span class="line">      <span class="attr">"nickName"</span>:<span class="string">"王五"</span>,</span><br><span class="line">      <span class="attr">"uid"</span>:<span class="number">10003</span></span><br><span class="line">   &#125;,   </span><br><span class="line">   <span class="attr">"pictureUrls"</span>:[</span><br><span class="line">      <span class="string">"http://cdnhost/pic/e1ea32968eb094232f74b712017e5d11.jpg"</span>,</span><br><span class="line">      <span class="string">"http://cdnhost/pic/e1ea32968eb094232f74b712017e5d12.jpg"</span>,</span><br><span class="line">      <span class="string">"http://cdnhost/pic/e1ea32968eb094232f74b712017e5d13.jpg"</span>,</span><br><span class="line">      <span class="string">"http://cdnhost/pic/e1ea32968eb094232f74b712017e5d14.jpg"</span>,</span><br><span class="line">      <span class="string">"http://cdnhost/pic/e1ea32968eb094232f74b712017e5d15.png"</span>,</span><br><span class="line">      <span class="string">"http://cdnhost/pic/e1ea32968eb094232f74b712017e5d16.png"</span>,</span><br><span class="line">      <span class="string">"http://cdnhost/pic/e1ea32968eb094232f74b712017e5d17.png"</span>,</span><br><span class="line">      <span class="string">"http://cdnhost/pic/e1ea32968eb094232f74b712017e5d18.png"</span>,</span><br><span class="line">      <span class="string">"http://cdnhost/pic/e1ea32968eb094232f74b712017e5d19.png"</span>,</span><br><span class="line">      <span class="string">"http://cdnhost/pic/e1ea32968eb094232f74b712017e5d10.png"</span></span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"comments"</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"author"</span>:&#123;</span><br><span class="line">            <span class="attr">"headImg"</span>:<span class="string">"http://cdnhost/headimg/5fdd5874ff6d571e6d0abac9660ec81f.jpg"</span>,</span><br><span class="line">            <span class="attr">"nickName"</span>:<span class="string">"麻子"</span>,</span><br><span class="line">            <span class="attr">"uid"</span>:<span class="number">10004</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">"commentCount"</span>:<span class="number">0</span>,</span><br><span class="line">         <span class="attr">"content"</span>:<span class="string">"这是一个回复678ijnfdsf"</span>,</span><br><span class="line">         <span class="attr">"createtime"</span>:<span class="number">1543374600935</span>,</span><br><span class="line">         <span class="attr">"id"</span>:<span class="number">500013</span>,</span><br><span class="line">         <span class="attr">"likeCount"</span>:<span class="number">0</span>,</span><br><span class="line">         <span class="attr">"postId"</span>:<span class="number">90012</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"author"</span>:&#123;</span><br><span class="line">            <span class="attr">"headImg"</span>:<span class="string">"http://cdnhost/headimg/5fdd5874ff6d571e6d0abac9660ec81f.jpg"</span>,</span><br><span class="line">            <span class="attr">"nickName"</span>:<span class="string">"麻子"</span>,</span><br><span class="line">            <span class="attr">"uid"</span>:<span class="number">10004</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">"commentCount"</span>:<span class="number">0</span>,</span><br><span class="line">         <span class="attr">"content"</span>:<span class="string">"这是一个回复678ijnfdsf"</span>,</span><br><span class="line">         <span class="attr">"createtime"</span>:<span class="number">1543374500935</span>,</span><br><span class="line">         <span class="attr">"id"</span>:<span class="number">500012</span>,</span><br><span class="line">         <span class="attr">"likeCount"</span>:<span class="number">0</span>,</span><br><span class="line">         <span class="attr">"postId"</span>:<span class="number">90012</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"author"</span>:&#123;</span><br><span class="line">            <span class="attr">"headImg"</span>:<span class="string">"http://cdnhost/headimg/01f8cc1938c30b28b1e80d256faddd84.jpg"</span>,</span><br><span class="line">            <span class="attr">"nickName"</span>:<span class="string">"听他们说玩游戏名字起得不能太长"</span>,</span><br><span class="line">            <span class="attr">"uid"</span>:<span class="number">10005</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">"commentCount"</span>:<span class="number">0</span>,</span><br><span class="line">         <span class="attr">"content"</span>:<span class="string">"这是一个回复678ijnfdsf"</span>,</span><br><span class="line">         <span class="attr">"createtime"</span>:<span class="number">1543374700935</span>,</span><br><span class="line">         <span class="attr">"id"</span>:<span class="number">500011</span>,</span><br><span class="line">         <span class="attr">"likeCount"</span>:<span class="number">0</span>,</span><br><span class="line">         <span class="attr">"postId"</span>:<span class="number">90012</span></span><br><span class="line">      &#125;</span><br><span class="line">   ],   </span><br><span class="line">   <span class="attr">"likes"</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"createTime"</span>:<span class="number">1543375480935</span>,</span><br><span class="line">         <span class="attr">"id"</span>:<span class="number">882211</span>,</span><br><span class="line">         <span class="attr">"postId"</span>:<span class="number">90012</span>,</span><br><span class="line">         <span class="attr">"user"</span>:&#123;</span><br><span class="line">            <span class="attr">"headImg"</span>:<span class="string">"http://cdnhost/headimg/e1ea32968eb094232f74b712017e5d14.jpg"</span>,</span><br><span class="line">            <span class="attr">"nickName"</span>:<span class="string">"李四"</span>,</span><br><span class="line">            <span class="attr">"uid"</span>:<span class="number">10002</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"createTime"</span>:<span class="number">1543375590935</span>,</span><br><span class="line">         <span class="attr">"id"</span>:<span class="number">882212</span>,</span><br><span class="line">         <span class="attr">"postId"</span>:<span class="number">90012</span>,</span><br><span class="line">         <span class="attr">"user"</span>:&#123;</span><br><span class="line">            <span class="attr">"headImg"</span>:<span class="string">"http://cdnhost/headimg/5fdd5874ff6d571e6d0abac9660ec81f.jpg"</span>,</span><br><span class="line">            <span class="attr">"nickName"</span>:<span class="string">"麻子"</span>,</span><br><span class="line">            <span class="attr">"uid"</span>:<span class="number">10004</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"createTime"</span>:<span class="number">1543375700935</span>,</span><br><span class="line">         <span class="attr">"id"</span>:<span class="number">882214</span>,</span><br><span class="line">         <span class="attr">"postId"</span>:<span class="number">90012</span>,</span><br><span class="line">         <span class="attr">"user"</span>:&#123;</span><br><span class="line">            <span class="attr">"headImg"</span>:<span class="string">"http://cdnhost/headimg/5fdd5874ff6d571e6d0abac9660ec81f.jpg"</span>,</span><br><span class="line">            <span class="attr">"nickName"</span>:<span class="string">"麻子"</span>,</span><br><span class="line">            <span class="attr">"uid"</span>:<span class="number">10004</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AREA1-模块"><a href="#AREA1-模块" class="headerlink" title="AREA1 模块"></a>AREA1 模块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&quot;category&quot;:&quot;PICTURE&quot;,</span><br><span class="line">   &quot;content&quot;:&quot;这是一个带9张图片的动态&quot;,</span><br><span class="line">   &quot;createtime&quot;:1543374370935,</span><br><span class="line">   &quot;id&quot;:90012,</span><br><span class="line">   &quot;likeCount&quot;:3,</span><br><span class="line">   &quot;commentCount&quot;:9,</span><br><span class="line">   &quot;device&quot;:&quot;红米 6&quot;,</span><br><span class="line">   &quot;geo&quot;:null,</span><br><span class="line">   &quot;author&quot;:&#123;</span><br><span class="line">      &quot;headImg&quot;:&quot;http://cdnhost/headimg/91d192886a5b9f3e14b6ffa1a674b55d.jpg&quot;,</span><br><span class="line">      &quot;nickName&quot;:&quot;王五&quot;,</span><br><span class="line">      &quot;uid&quot;:10003</span><br><span class="line">   &#125;,   </span><br><span class="line">   &quot;pictureUrls&quot;:[</span><br><span class="line">      &quot;http://cdnhost/pic/e1ea32968eb094232f74b712017e5d11.jpg&quot;,</span><br><span class="line">      &quot;http://cdnhost/pic/e1ea32968eb094232f74b712017e5d12.jpg&quot;,</span><br><span class="line">      &quot;http://cdnhost/pic/e1ea32968eb094232f74b712017e5d13.jpg&quot;,</span><br><span class="line">      &quot;http://cdnhost/pic/e1ea32968eb094232f74b712017e5d14.jpg&quot;,</span><br><span class="line">      &quot;http://cdnhost/pic/e1ea32968eb094232f74b712017e5d15.png&quot;,</span><br><span class="line">      &quot;http://cdnhost/pic/e1ea32968eb094232f74b712017e5d16.png&quot;,</span><br><span class="line">      &quot;http://cdnhost/pic/e1ea32968eb094232f74b712017e5d17.png&quot;,</span><br><span class="line">      &quot;http://cdnhost/pic/e1ea32968eb094232f74b712017e5d18.png&quot;,</span><br><span class="line">      &quot;http://cdnhost/pic/e1ea32968eb094232f74b712017e5d19.png&quot;,</span><br><span class="line">      &quot;http://cdnhost/pic/e1ea32968eb094232f74b712017e5d10.png&quot;</span><br><span class="line">   ],</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><h4 id="AREA2-comments-模块"><a href="#AREA2-comments-模块" class="headerlink" title="AREA2 comments 模块"></a>AREA2 comments 模块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&quot;comments&quot;:[</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;author&quot;:&#123;</span><br><span class="line">            &quot;headImg&quot;:&quot;http://cdnhost/headimg/5fdd5874ff6d571e6d0abac9660ec81f.jpg&quot;,</span><br><span class="line">            &quot;nickName&quot;:&quot;麻子&quot;,</span><br><span class="line">            &quot;uid&quot;:10004</span><br><span class="line">         &#125;,</span><br><span class="line">         &quot;commentCount&quot;:0,</span><br><span class="line">         &quot;content&quot;:&quot;这是一个回复678ijnfdsf&quot;,</span><br><span class="line">         &quot;createtime&quot;:1543374600935,</span><br><span class="line">         &quot;id&quot;:500013,</span><br><span class="line">         &quot;likeCount&quot;:0,</span><br><span class="line">         &quot;postId&quot;:90012</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;author&quot;:&#123;</span><br><span class="line">            &quot;headImg&quot;:&quot;http://cdnhost/headimg/5fdd5874ff6d571e6d0abac9660ec81f.jpg&quot;,</span><br><span class="line">            &quot;nickName&quot;:&quot;麻子&quot;,</span><br><span class="line">            &quot;uid&quot;:10004</span><br><span class="line">         &#125;,</span><br><span class="line">         &quot;commentCount&quot;:0,</span><br><span class="line">         &quot;content&quot;:&quot;这是一个回复678ijnfdsf&quot;,</span><br><span class="line">         &quot;createtime&quot;:1543374500935,</span><br><span class="line">         &quot;id&quot;:500012,</span><br><span class="line">         &quot;likeCount&quot;:0,</span><br><span class="line">         &quot;postId&quot;:90012</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;author&quot;:&#123;</span><br><span class="line">            &quot;headImg&quot;:&quot;http://cdnhost/headimg/01f8cc1938c30b28b1e80d256faddd84.jpg&quot;,</span><br><span class="line">            &quot;nickName&quot;:&quot;听他们说玩游戏名字起得不能太长&quot;,</span><br><span class="line">            &quot;uid&quot;:10005</span><br><span class="line">         &#125;,</span><br><span class="line">         &quot;commentCount&quot;:0,</span><br><span class="line">         &quot;content&quot;:&quot;这是一个回复678ijnfdsf&quot;,</span><br><span class="line">         &quot;createtime&quot;:1543374700935,</span><br><span class="line">         &quot;id&quot;:500011,</span><br><span class="line">         &quot;likeCount&quot;:0,</span><br><span class="line">         &quot;postId&quot;:90012</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure><h4 id="AREA2-comments-模块存储优化"><a href="#AREA2-comments-模块存储优化" class="headerlink" title="AREA2 comments 模块存储优化"></a>AREA2 comments 模块存储优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;comments_postid&quot;:[</span><br><span class="line">500013,</span><br><span class="line">500012,</span><br><span class="line">500011,</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="AREA2-likes-模块"><a href="#AREA2-likes-模块" class="headerlink" title="AREA2 likes 模块"></a>AREA2 likes 模块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&quot;likes&quot;:[</span><br><span class="line">   &#123;</span><br><span class="line">      &quot;createTime&quot;:1543375480935,</span><br><span class="line">      &quot;id&quot;:882211,</span><br><span class="line">      &quot;postId&quot;:90012,</span><br><span class="line">      &quot;user&quot;:&#123;</span><br><span class="line">         &quot;headImg&quot;:&quot;http://cdnhost/headimg/e1ea32968eb094232f74b712017e5d14.jpg&quot;,</span><br><span class="line">         &quot;nickName&quot;:&quot;李四&quot;,</span><br><span class="line">         &quot;uid&quot;:10002</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">      &quot;createTime&quot;:1543375590935,</span><br><span class="line">      &quot;id&quot;:882212,</span><br><span class="line">      &quot;postId&quot;:90012,</span><br><span class="line">      &quot;user&quot;:&#123;</span><br><span class="line">         &quot;headImg&quot;:&quot;http://cdnhost/headimg/5fdd5874ff6d571e6d0abac9660ec81f.jpg&quot;,</span><br><span class="line">         &quot;nickName&quot;:&quot;麻子&quot;,</span><br><span class="line">         &quot;uid&quot;:10004</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">      &quot;createTime&quot;:1543375700935,</span><br><span class="line">      &quot;id&quot;:882214,</span><br><span class="line">      &quot;postId&quot;:90012,</span><br><span class="line">      &quot;user&quot;:&#123;</span><br><span class="line">         &quot;headImg&quot;:&quot;http://cdnhost/headimg/5fdd5874ff6d571e6d0abac9660ec81f.jpg&quot;,</span><br><span class="line">         &quot;nickName&quot;:&quot;麻子&quot;,</span><br><span class="line">         &quot;uid&quot;:10004</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="AREA2-likes-模块存储优化"><a href="#AREA2-likes-模块存储优化" class="headerlink" title="AREA2 likes 模块存储优化"></a>AREA2 likes 模块存储优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;likes_postid&quot;:[</span><br><span class="line">882211,</span><br><span class="line">882212,</span><br><span class="line">882214,</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="最终的储存结构"><a href="#最终的储存结构" class="headerlink" title="最终的储存结构"></a>最终的储存结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;category&quot;:&quot;PICTURE&quot;,</span><br><span class="line">   &quot;content&quot;:&quot;这是一个带9张图片的动态&quot;,</span><br><span class="line">   &quot;createtime&quot;:1543374370935,</span><br><span class="line">   &quot;id&quot;:90012,</span><br><span class="line">   &quot;likeCount&quot;:3,</span><br><span class="line">   &quot;commentCount&quot;:9,</span><br><span class="line">   &quot;device&quot;:&quot;红米 6&quot;,</span><br><span class="line">   &quot;geo&quot;:null,</span><br><span class="line">   &quot;author_uid&quot;:10003,</span><br><span class="line">   &quot;comments_postid&quot;:[</span><br><span class="line">      500013,</span><br><span class="line">      500012,</span><br><span class="line">      500011,</span><br><span class="line">      ...</span><br><span class="line">   ],</span><br><span class="line">   &quot;likes_postid&quot;:[</span><br><span class="line">      882211,</span><br><span class="line">      882212,</span><br><span class="line">      882214,</span><br><span class="line">      ...</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>2018.11.29<br>补充一下。<code>likeCount</code> <code>commentCount</code> 是实时计算的出来的，而不是持久化在mongodb中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;以微信朋友圈为例，但又与微信不同是微信是以强社交为主，只有好友之间才可以查阅对方的朋友圈内容，而我们当前的设计类似的微博以弱社交的表现形式，其显著特点就是即便互相没有关注也可以访问对方的朋友圈数据。所以设计之初首先要确认应用场景是&lt;code&gt;强社交&lt;/code&gt;，还是&lt;code&gt;弱社交&lt;/code&gt;关系。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="https://blog.fanfq.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="https://blog.fanfq.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="mongodb" scheme="https://blog.fanfq.com/tags/mongodb/"/>
    
      <category term="design" scheme="https://blog.fanfq.com/tags/design/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq quick setup for ubuntu</title>
    <link href="https://blog.fanfq.com/%E6%9E%B6%E6%9E%84/rabbitmq_quick_setup.html"/>
    <id>https://blog.fanfq.com/架构/rabbitmq_quick_setup.html</id>
    <published>2018-11-16T04:13:43.000Z</published>
    <updated>2021-02-04T02:44:22.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#install</span><br><span class="line">echo &quot;deb https://dl.bintray.com/rabbitmq/debian xenial main&quot; | sudo tee /etc/apt/sources.list.d/bintray.rabbitmq.list</span><br><span class="line">wget -O- https://www.rabbitmq.com/rabbitmq-release-signing-key.asc | sudo apt-key add -</span><br><span class="line">sudo apt-get install rabbitmq-server</span><br><span class="line"></span><br><span class="line">#service start</span><br><span class="line">service rabbitmq-server start</span><br><span class="line">sudo service rabbitmq-server status</span><br><span class="line"></span><br><span class="line">#web admin</span><br><span class="line">sudo rabbitmq-plugins enable rabbitmq_management</span><br><span class="line">#login by guest</span><br><span class="line">127.0.0.1:15672 guest guest</span><br><span class="line"></span><br><span class="line">#new user</span><br><span class="line">sudo rabbitmqctl add_user fanfq fanfq</span><br><span class="line">sudo rabbitmqctl set_user_tags fanfq administrator</span><br></pre></td></tr></table></figure><p>如果是服务器安装，客户端是没法通过guest用户登录的，则需要创建一个新的用户并赋予admin权限，后续的操作均可通过网页管理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="架构" scheme="https://blog.fanfq.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="https://blog.fanfq.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="服务器" scheme="https://blog.fanfq.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="集群" scheme="https://blog.fanfq.com/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="rabbitmq" scheme="https://blog.fanfq.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>手机APP大数据归因精准匹配之研发摘要</title>
    <link href="https://blog.fanfq.com/%E7%AE%97%E6%B3%95/%E6%89%8B%E6%9C%BAAPP%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BD%92%E5%9B%A0%E7%B2%BE%E5%87%86%E5%8C%B9%E9%85%8D%E4%B9%8B%E7%A0%94%E5%8F%91%E6%91%98%E8%A6%81.html"/>
    <id>https://blog.fanfq.com/算法/手机APP大数据归因精准匹配之研发摘要.html</id>
    <published>2018-11-13T02:55:49.000Z</published>
    <updated>2018-11-14T09:23:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>透过覆盖我的黑夜,<br>我看见层层无底的黑暗。<br>感谢上帝赐我,<br>不可征服的灵魂。<br>就算被地狱紧紧攫住,<br>我不会畏缩，也不惊叫。<br>经受过一浪 又一浪的打击，<br>我满头鲜血不低头。<br>在这满是愤怒和眼泪的世界之外,<br>恐怖的阴影在游荡,<br>还有，未来的威胁,<br>可是我毫不畏惧。<br>无论我将穿过的那扇门有多窄，<br>无论我将肩承怎样的责罚。<br>我是命运的主宰,<br>我是灵魂的统帅。</p><footer><strong>19世纪英国诗人威廉亨利《不可征服》</strong></footer></blockquote><p><br></p><p>2016年我从外企到一家创业公司接手的第一个工作任务，从此之后我就与他展开了不解之缘。我们为了提高1%的准确率要花费100%的努力，直到现在为止我们都在为了哪怕只能提高0.1%的准确率而不懈努力。</p><a id="more"></a><h2 id="核心摘要"><a href="#核心摘要" class="headerlink" title="核心摘要"></a>核心摘要</h2><h3 id="direct-download-link"><a href="#direct-download-link" class="headerlink" title="direct download link"></a>direct download link</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">custom download link for apk file</span><br><span class="line">https://dlhost/&#123;apkname&#125;</span><br><span class="line"></span><br><span class="line">appstore</span><br><span class="line">https://itunes.apple.com/&#123;appid&#125;</span><br><span class="line"></span><br><span class="line">google play</span><br><span class="line">https://play.google.com/store/apps/details?id=&#123;packagename&#125;</span><br></pre></td></tr></table></figure><h3 id="track-link"><a href="#track-link" class="headerlink" title="track link"></a>track link</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://tlhost/&#123;schema&#125;</span><br><span class="line">| - storage to db &amp; redirect to</span><br><span class="line">|-&gt; https://dlhost/&#123;apkname&#125;</span><br><span class="line">|-&gt; https://itunes.apple.com/&#123;appid&#125;</span><br><span class="line">|-&gt; https://play.google.com/store/apps/details?id=&#123;packagename&#125;</span><br></pre></td></tr></table></figure><h3 id="sdk-track"><a href="#sdk-track" class="headerlink" title="sdk track"></a>sdk track</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST DATA To Server</span><br><span class="line">https://apihost?data=&#123;DATA&#125;</span><br></pre></td></tr></table></figure><h3 id="server-side"><a href="#server-side" class="headerlink" title="server side"></a>server side</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">click event （data from track link, such as QR Code、SNS Media、Web Browser, etc.）</span><br><span class="line">-&gt; storage to db</span><br><span class="line"></span><br><span class="line">install &amp; launch event （data from sdk track，such as install and first launch or others）</span><br><span class="line">-&gt; storage to db</span><br><span class="line"></span><br><span class="line">matching accuracy (importance, the big data algorithm)</span><br><span class="line">-&gt; matching click / install data</span><br></pre></td></tr></table></figure><ol><li>track link<br> 跳转之前可以做很多事情，如获取浏览器信息，设置cookie，甚至持久化session</li><li>sdk track<br> 第一次安装启动时可以通过sdk传递数据到服务器，同track link的操作类似</li><li>matching<br> 通过获取到数据进行匹配，难点就在此了，这也是整个项目的核心。</li></ol><h3 id="simple-workflow"><a href="#simple-workflow" class="headerlink" title="simple workflow"></a>simple workflow</h3><img src="/uploads/20181113_workflow.png"><p>读到这里，如果你还没有看懂我在说什么，也想这篇文章不适合你继续读下去。虽然我写的也不是给谁看的，也不知道谁会关注此文。</p><h2 id="商业服务"><a href="#商业服务" class="headerlink" title="商业服务"></a>商业服务</h2><p>这个服务已经有了成熟的三方供应商，如比较知名有 <code>Adjust</code>，<code>Appsflyer</code>，<code>TalkingData</code>，<code>Google Firebase</code> 等等。</p><p>他们的共同特点出了收费外，都号称100%的精准，实际上使用下来准确率达到70%+就算很不错了，实际上在复杂的网络环境能达到70%以上的准确率是相当难的。不过通过海量数据的日益积累，以及算法的跟新迭代准确率只会越来越高。</p><p>同时他们还对接各个主流流量平台，提高准确率的同时还方便了用户。我个人认为此服务未来将成为所有APP的缺省功能，只要你的APP需要用户，只要你要去做分发，此服务不可或缺的。</p><p>当然如果你有足够的研发能力，以及对数据的高度敏感也可以直接去开发此类系统。因为使用三方服务就得牺牲用户数据，也许不会泄露这些用户数据可以肯定他们会利用这些数据。像Facebook，微信这种体量的APP他们都有自己的跟踪系统。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;透过覆盖我的黑夜,&lt;br&gt;我看见层层无底的黑暗。&lt;br&gt;感谢上帝赐我,&lt;br&gt;不可征服的灵魂。&lt;br&gt;就算被地狱紧紧攫住,&lt;br&gt;我不会畏缩，也不惊叫。&lt;br&gt;经受过一浪 又一浪的打击，&lt;br&gt;我满头鲜血不低头。&lt;br&gt;在这满是愤怒和眼泪的世界之外,&lt;br&gt;恐怖的阴影在游荡,&lt;br&gt;还有，未来的威胁,&lt;br&gt;可是我毫不畏惧。&lt;br&gt;无论我将穿过的那扇门有多窄，&lt;br&gt;无论我将肩承怎样的责罚。&lt;br&gt;我是命运的主宰,&lt;br&gt;我是灵魂的统帅。&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;19世纪英国诗人威廉亨利《不可征服》&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;2016年我从外企到一家创业公司接手的第一个工作任务，从此之后我就与他展开了不解之缘。我们为了提高1%的准确率要花费100%的努力，直到现在为止我们都在为了哪怕只能提高0.1%的准确率而不懈努力。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://blog.fanfq.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://blog.fanfq.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="大数据" scheme="https://blog.fanfq.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="归因" scheme="https://blog.fanfq.com/tags/%E5%BD%92%E5%9B%A0/"/>
    
      <category term="tracking" scheme="https://blog.fanfq.com/tags/tracking/"/>
    
  </entry>
  
  <entry>
    <title>SALT Encrypt Best Practices</title>
    <link href="https://blog.fanfq.com/%E7%AE%97%E6%B3%95/SALT_Encrypt_Best_Practices.html"/>
    <id>https://blog.fanfq.com/算法/SALT_Encrypt_Best_Practices.html</id>
    <published>2018-10-31T01:14:33.000Z</published>
    <updated>2018-11-07T01:23:19.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="发现问题："><a href="#发现问题：" class="headerlink" title="发现问题："></a>发现问题：</h2><p>这里展示一个简易的用户表：</p><table><thead><tr><th>uid</th><th>username</th><th>password</th></tr></thead><tbody><tr><td>1</td><td>zhangsan</td><td>e10adc3949ba59abbe56e057f20f883e</td></tr><tr><td>2</td><td>lisi</td><td>e10adc3949ba59abbe56e057f20f883e</td></tr><tr><td>3</td><td>wangwu</td><td>9bd5ee6fe55aaeb673025dbcb8f939c1</td></tr><tr><td>4</td><td>laoz</td><td>f8a8d7997e870968f92748f3cc41cf90</td></tr></tbody></table><ol><li>我们发现 UID 1,2 对应的 password 是一样的，如果我是zhangsan，那岂不是同样我也知道lisi的密码明文是什么了？</li><li>通过MD5密码破解网站，轻易的得到 <code>e10adc3949ba59abbe56e057f20f883e</code> 对应的明文是 <code>123456</code></li></ol><a id="more"></a><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>我们知道，如果直接对密码进行散列，那么黑客可以对通过获得这个密码散列值，然后通过查散列值字典（例如MD5密码破解网站），得到某用户的密码。</p><p>加Salt可以一定程度上解决这一问题。所谓加Salt方法，就是加点“佐料”。其基本想法是这样的：当用户首次提供密码时（通常是注册时），由系统自动往这个密码里撒一些“佐料”，然后再散列。而当用户登录时，系统为用户提供的代码撒上同样的“佐料”，然后散列，再比较散列值，已确定密码是否正确。</p><p>这里的“佐料”被称作“Salt值”也称“盐值”，这个加“佐料”的行为叫做“加盐”，这个值是由系统随机生成的，并且只有系统知道。这样，即便两个用户使用了同一个密码，由于系统为它们生成的salt值不同，他们的散列值也是不同的。即便黑客可以通过自己的密码和自己生成的散列值来找具有特定密码的用户，但这个几率太小了（密码和salt值都得和黑客使用的一样才行）。</p><p>有时候，为了减轻开发压力，程序员会统一使用一个salt值（储存在某个地方），而不是每个用户都生成私有的salt值。但是这样的话还是解决不了上述我们发现同密文反推明文的问题。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">salt=random()<span class="comment">//获取一个随机的字符串</span></span><br><span class="line">src=<span class="number">123456</span></span><br><span class="line">password=md5(salt+src)</span><br></pre></td></tr></table></figure><p>下面详细介绍一下加Salt散列的过程。介绍之前先强调一点，前面说过，验证密码时要使用和最初散列密码时使用“相同的”佐料。所以Salt值是要存放在数据库里的。</p><h3 id="用户注册时"><a href="#用户注册时" class="headerlink" title="用户注册时"></a>用户注册时</h3><p>用户输入【账号】和【密码】（以及其他用户信息）；<br>系统为用户生成【Salt值】；<br>系统将【Salt值】和【用户密码】连接到一起；<br>对连接后的值进行散列，得到【Hash值】；<br>将【Hash值1】和【Salt值】分别放到数据库中。</p><h3 id="用户登录时"><a href="#用户登录时" class="headerlink" title="用户登录时"></a>用户登录时</h3><p>用户输入【账号】和【密码】；<br>系统通过用户名找到与之对应的【Hash值】和【Salt值】；<br>系统将【Salt值】和【用户输入的密码】连接到一起；<br>对连接后的值进行散列，得到【Hash值2】（注意是即时运算出来的值）；<br>比较【Hash值1】和【Hash值2】是否相等，相等则表示密码正确，否则表示密码错误。</p><h3 id="增强版用户表设计"><a href="#增强版用户表设计" class="headerlink" title="增强版用户表设计"></a>增强版用户表设计</h3><table><thead><tr><th>uid</th><th>username</th><th>password</th><th>salt</th></tr></thead><tbody><tr><td>1</td><td>zhangsan</td><td>ad4b3e001f961ef2792ccaae9d05c873</td><td>eyJ1a</td></tr><tr><td>2</td><td>lisi</td><td>f73f9c73c5e6e6059c9948a78ee81957</td><td>WQiOj</td></tr><tr><td>3</td><td>wangwu</td><td>9bd5ee6fe55aaeb673025dbcb8f939c1</td><td>EwMDE</td></tr><tr><td>4</td><td>laoz</td><td>f8a8d7997e870968f92748f3cc41cf90</td><td>U0MDk</td></tr></tbody></table><p>即便 zhangsan，lisi 的密码明文都是 123456，由于他们的salt不同则最终的password密文也不同，由于salt增加的密码的复杂度，被破解的难度也更大。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;发现问题：&quot;&gt;&lt;a href=&quot;#发现问题：&quot; class=&quot;headerlink&quot; title=&quot;发现问题：&quot;&gt;&lt;/a&gt;发现问题：&lt;/h2&gt;&lt;p&gt;这里展示一个简易的用户表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;uid&lt;/th&gt;
&lt;th&gt;username&lt;/th&gt;
&lt;th&gt;password&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;zhangsan&lt;/td&gt;
&lt;td&gt;e10adc3949ba59abbe56e057f20f883e&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;lisi&lt;/td&gt;
&lt;td&gt;e10adc3949ba59abbe56e057f20f883e&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;wangwu&lt;/td&gt;
&lt;td&gt;9bd5ee6fe55aaeb673025dbcb8f939c1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;laoz&lt;/td&gt;
&lt;td&gt;f8a8d7997e870968f92748f3cc41cf90&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;我们发现 UID 1,2 对应的 password 是一样的，如果我是zhangsan，那岂不是同样我也知道lisi的密码明文是什么了？&lt;/li&gt;
&lt;li&gt;通过MD5密码破解网站，轻易的得到 &lt;code&gt;e10adc3949ba59abbe56e057f20f883e&lt;/code&gt; 对应的明文是 &lt;code&gt;123456&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="算法" scheme="https://blog.fanfq.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://blog.fanfq.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="openapi" scheme="https://blog.fanfq.com/tags/openapi/"/>
    
  </entry>
  
  <entry>
    <title>Access Token vs Refresh Token</title>
    <link href="https://blog.fanfq.com/%E7%AE%97%E6%B3%95/AccessToken_RefreshToken.html"/>
    <id>https://blog.fanfq.com/算法/AccessToken_RefreshToken.html</id>
    <published>2018-10-30T14:26:57.000Z</published>
    <updated>2020-11-04T08:36:36.121Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="设计需求"><a href="#设计需求" class="headerlink" title="设计需求"></a>设计需求</h2><ol><li>统计在线列表，可以随时的踢下线，让客户端缓存的token失效</li><li>30天内无需重新登录，默认可无限期延续</li></ol><h2 id="Token生成方案"><a href="#Token生成方案" class="headerlink" title="Token生成方案"></a>Token生成方案</h2><a id="more"></a><h3 id="JWT（JSON-WEB-TOKEN）的构成"><a href="#JWT（JSON-WEB-TOKEN）的构成" class="headerlink" title="JWT（JSON WEB TOKEN）的构成"></a>JWT（JSON WEB TOKEN）的构成</h3><p>第一部分我们称它为头部（header),<br>第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，<br>第三部分是签名（signature确保数据的完整性).<br><code>JWT token = header.payload.signature</code><br>由于JWT是无状态的，也未能实现我们上述的需求，所以不得不放弃了JWT的方案，但是其有关token的加密算法还是值得参考的。</p><h3 id="access-token生成方案"><a href="#access-token生成方案" class="headerlink" title="access_token生成方案"></a>access_token生成方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">payload = urlencode(base64(&#123;uid,ts&#125;))</span><br><span class="line">salt=TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ //盐值</span><br><span class="line">signature = HMACSHA256(payload,salt);</span><br><span class="line">access_token = payload.signature</span><br><span class="line"></span><br><span class="line">redis_key = access_token:uid:&#123;access_token&#125;//uid 是从token中payload解析出来的</span><br><span class="line">redis_value = userinfo</span><br><span class="line">redis_ttl = 2hr</span><br></pre></td></tr></table></figure><h3 id="refresh-token生成方案"><a href="#refresh-token生成方案" class="headerlink" title="refresh_token生成方案"></a>refresh_token生成方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">payload = urlencode(base64(&#123;uid,ts&#125;))</span><br><span class="line">salt=TJVA95Or11.0cBab30RMHrHDcEfxjoYZgeFONFh7HgQ //盐值</span><br><span class="line">signature = HMACSHA256(payload,salt);</span><br><span class="line">refresh_token = payload.signature;</span><br><span class="line"></span><br><span class="line">redis_key = refresh_token:uid:&#123;refresh_token&#125;//uid 是从token中payload解析出来的</span><br><span class="line">redis_value = access_token</span><br><span class="line">redis_ttl = 30days</span><br></pre></td></tr></table></figure><h3 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"><span class="keyword">import</span> com.fanfq.util.commons.encrypt.HMACSHA256;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"\n#####token生成算法"</span>);</span><br><span class="line">    </span><br><span class="line">Long uid = <span class="number">10010l</span>;</span><br><span class="line"></span><br><span class="line">Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">    map.put(<span class="string">"uid"</span>, uid);</span><br><span class="line">    map.put(<span class="string">"ts"</span>, System.currentTimeMillis());</span><br><span class="line">    </span><br><span class="line">    String str = JSONObject.toJSONString(map);</span><br><span class="line">    </span><br><span class="line">    String base64 = Base64.encodeBase64String(str.getBytes());</span><br><span class="line">    String payload = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        payload = URLEncoder.encode(base64,<span class="string">"UTF-8"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">String salt = <span class="string">"TJVA95Or11.0cBab30RMHrHDcEfxjoYZgeFONFh7HgQ"</span>;</span><br><span class="line">String signature = HMACSHA256.encode(payload,salt);</span><br><span class="line"></span><br><span class="line">String token = payload+<span class="string">"."</span>+signature;</span><br><span class="line">System.out.println(<span class="string">"payload:"</span>+payload);</span><br><span class="line">System.out.println(<span class="string">"signature:"</span>+signature);</span><br><span class="line">System.out.println(<span class="string">"token:"</span>+token);</span><br><span class="line">System.out.println(<span class="string">"redis key: token:"</span>+uid+<span class="string">":"</span>+token);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"\n#####token校验算法"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"1.签名校验"</span>);</span><br><span class="line">System.out.println(<span class="string">"token:"</span>+token);</span><br><span class="line">String payload_ = token.split(<span class="string">"\\."</span>)[<span class="number">0</span>];</span><br><span class="line">String signature_ = token.split(<span class="string">"\\."</span>)[<span class="number">1</span>];</span><br><span class="line">System.out.println(<span class="string">"payload密文:"</span>+payload_);</span><br><span class="line">System.out.println(<span class="string">"signature签名:"</span>+signature_);</span><br><span class="line"><span class="keyword">boolean</span> check = HMACSHA256.encode(payload_,salt).equals(signature_);</span><br><span class="line">System.out.println(<span class="string">"签名校验："</span>+check);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"\n2.时间戳校验"</span>);</span><br><span class="line">String urldecode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    urldecode = URLDecoder.decode(payload_, <span class="string">"UTF-8"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">String jsondecode = <span class="keyword">new</span> String(Base64.decodeBase64(urldecode));</span><br><span class="line">System.out.println(<span class="string">"payload解密："</span>+jsondecode);</span><br><span class="line"></span><br><span class="line">JSONObject jsobj = JSONObject.parseObject(jsondecode);</span><br><span class="line">Long ts = jsobj.getLong(<span class="string">"ts"</span>);</span><br><span class="line">System.out.println(System.currentTimeMillis() - ts +<span class="string">" ms"</span>);</span><br><span class="line"><span class="keyword">if</span>(System.currentTimeMillis() - ts &gt; <span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">2</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"超过2小时"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"有效期内，开始进行redis查询"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>token生成算法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">明文：&#123;&quot;uid&quot;:10010,&quot;ts&quot;:1540912751948&#125;</span><br><span class="line">payload:eyJ1aWQiOjEwMDEwLCJ0cyI6MTU0MDkxMjc1MTk0OH0%3D</span><br><span class="line">signature:0ba40cff2bda8fab9ae61893b43c198e3022a1e8f058ac8054417241d3129d1f</span><br><span class="line">token:eyJ1aWQiOjEwMDEwLCJ0cyI6MTU0MDkxMjc1MTk0OH0%3D.0ba40cff2bda8fab9ae61893b43c198e3022a1e8f058ac8054417241d3129d1f</span><br><span class="line">redis key: token:10010:eyJ1aWQiOjEwMDEwLCJ0cyI6MTU0MDkxMjc1MTk0OH0%3D.0ba40cff2bda8fab9ae61893b43c198e3022a1e8f058ac8054417241d3129d1f</span><br></pre></td></tr></table></figure></p><p><strong>token校验算法</strong></p><ol><li><p>签名校验</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">token:eyJ1aWQiOjEwMDEwLCJ0cyI6MTU0MDkxMjc1MTk0OH0%3D.0ba40cff2bda8fab9ae61893b43c198e3022a1e8f058ac8054417241d3129d1f</span><br><span class="line">payload密文:eyJ1aWQiOjEwMDEwLCJ0cyI6MTU0MDkxMjc1MTk0OH0%3D</span><br><span class="line">signature签名:0ba40cff2bda8fab9ae61893b43c198e3022a1e8f058ac8054417241d3129d1f</span><br><span class="line">签名校验：true</span><br></pre></td></tr></table></figure></li><li><p>时间戳校验</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload解密：&#123;&quot;uid&quot;:10010,&quot;ts&quot;:1540912751948&#125;</span><br><span class="line">690 ms</span><br><span class="line">有效期内，开始进行redis查询</span><br></pre></td></tr></table></figure></li></ol><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>这个也是我经过思考后最终确认下来的token生成算法，也许你也发现既然redis持久化了就直接查库即可，无需搞的这么复杂的算法。实际上我是这样考虑的，因为大量的api请求都会带token参数导致每次请求都会查询库，固然redis的强大的性能足以支持，但还是为了效率过滤一些没有必要的io资源。</p><ol><li>得到请求的时候首先验证signature是否匹配，防止篡改</li><li>再从payload中获取ts以判断时间戳是否失效，access_token 2hr, refresh_token 30days.</li><li>前两者校验完成，则请求一次redis io做最终的判断。当然排除临时被提下线的情况下，大部分情况下这里都是通过的。</li><li><p>redis key 的设计，其中的uid设计主要是为了后期统计使用，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">keys （refresh_token:uid:*）获取当前终端连接数，</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; setz = jedis.keys(&quot;access_token:*&quot;);</span><br><span class="line">System.out.println(&quot;access_token:* key 的数目:&quot;+setz.size());</span><br><span class="line"></span><br><span class="line">获取当前在线用户数（根据uid排重）</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; setzz = new HashSet&lt;String&gt;();</span><br><span class="line">for(String str:setz) &#123;</span><br><span class="line">    setzz.add(str.split(&quot;:&quot;)[1]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;key uid 去重：&quot;+setzz.size());</span><br></pre></td></tr></table></figure></li><li><p>redis ttl 就不用不多说了，access_token 2hr, refresh_token 30days.</p></li><li>redis value：whatever anythings</li></ol><h3 id="Redis-有状态缓存"><a href="#Redis-有状态缓存" class="headerlink" title="Redis 有状态缓存"></a>Redis 有状态缓存</h3><p><strong>access_token</strong></p><table><thead><tr><th>key</th><th>ttl</th><th>value</th></tr></thead><tbody><tr><td>access_token:10024:ak_1</td><td>2hr</td><td>username:zhangsan,uid:10024</td></tr><tr><td>access_token:10025:ak_2</td><td>2hr</td><td>username:lisi,uid:10025</td></tr></tbody></table><p><strong>refresh_token</strong></p><table><thead><tr><th>key</th><th>ttl</th><th>value</th></tr></thead><tbody><tr><td>refresh_token:10024:rk_1</td><td>30days</td><td>access_token:10024:ak_1</td></tr><tr><td>refresh_token:10025:rk_2</td><td>30days</td><td>access_token:10025:ak_2</td></tr></tbody></table><h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h2><img src="/uploads/WX20181030-160602.png"><h2 id="用户授权获取token"><a href="#用户授权获取token" class="headerlink" title="用户授权获取token"></a>用户授权获取token</h2><h3 id="请求方法："><a href="#请求方法：" class="headerlink" title="请求方法："></a>请求方法：</h3><p><code>https://apihost/oauth2/access_token?username=zhangsan&amp;password=123456</code></p><h3 id="正确的返回："><a href="#正确的返回：" class="headerlink" title="正确的返回："></a>正确的返回：</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"code"</span>:<span class="number">200</span>,   </span><br><span class="line">   <span class="attr">"msg"</span>:<span class="string">"ok"</span>,   </span><br><span class="line">   <span class="attr">"data"</span>:&#123;</span><br><span class="line">      <span class="attr">"access_token"</span>:<span class="string">"ak_1"</span>,</span><br><span class="line">      <span class="attr">"uid"</span>:<span class="number">10024</span>,</span><br><span class="line">      <span class="attr">"refresh_token"</span>:<span class="string">"rk_1"</span>,</span><br><span class="line">      <span class="attr">"expires_in"</span>:<span class="number">7200</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>access_token</td><td>接口调用凭证</td></tr><tr><td>refresh_token</td><td>用户刷新access_token</td></tr><tr><td>uid</td><td>授权用户唯一标识</td></tr><tr><td>expires_in</td><td>access_token接口调用凭证超时时间，单位（秒）</td></tr></tbody></table><h3 id="错误返回样例："><a href="#错误返回样例：" class="headerlink" title="错误返回样例："></a>错误返回样例：</h3><p><code>{&quot;code&quot;:400,&quot;msg&quot;:&quot;bad request&quot;}</code></p><h2 id="刷新access-token有效期"><a href="#刷新access-token有效期" class="headerlink" title="刷新access_token有效期"></a>刷新access_token有效期</h2><p>access_token是调用授权关系接口的调用凭证，由于access_token有效期（目前为2个小时）较短，当access_token超时后，可以使用refresh_token进行刷新，用refresh_token仅能使用一次，使用一次后，将被废弃。也就是说refresh_token 更新 access_token 的时候 refresh_token 也会跟着被更新</p><ol><li>通过用refresh_token机制可以确保活跃用户长期不用登录授权。</li><li>refresh_token拥有较长的有效期（30天），当refresh_token失效的后，需要用户重新授权。也就说第一次登录与第二次登录时长间隔30天以上则需要用户重新授权登录。</li></ol><h3 id="请求方法：-1"><a href="#请求方法：-1" class="headerlink" title="请求方法："></a>请求方法：</h3><p><code>https://apihost/oauth2/refresh_token?uid=UID&amp;refresh_token=REFRESH_TOKEN</code></p><h3 id="正确的返回：-1"><a href="#正确的返回：-1" class="headerlink" title="正确的返回："></a>正确的返回：</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"code"</span>:<span class="number">200</span>,   </span><br><span class="line">   <span class="attr">"msg"</span>:<span class="string">"ok"</span>,   </span><br><span class="line">   <span class="attr">"data"</span>:&#123;</span><br><span class="line">      <span class="attr">"access_token"</span>:<span class="string">"ak_1"</span>,</span><br><span class="line">      <span class="attr">"uid"</span>:<span class="number">10024</span>,</span><br><span class="line">      <span class="attr">"refresh_token"</span>:<span class="string">"rk_1"</span>,</span><br><span class="line">      <span class="attr">"expires_in"</span>:<span class="number">7200</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>access_token</td><td>接口调用凭证</td></tr><tr><td>refresh_token</td><td>用户刷新access_token</td></tr><tr><td>uid</td><td>授权用户唯一标识</td></tr><tr><td>expires_in</td><td>access_token接口调用凭证超时时间，单位（秒）</td></tr></tbody></table><h3 id="错误返回样例：-1"><a href="#错误返回样例：-1" class="headerlink" title="错误返回样例："></a>错误返回样例：</h3><p><code>{&quot;code&quot;:400,&quot;msg&quot;:&quot;invalid refresh_token&quot;}</code></p><h2 id="通过access-token调用接口"><a href="#通过access-token调用接口" class="headerlink" title="通过access_token调用接口"></a>通过access_token调用接口</h2><p>获取access_token后，进行接口调用，有以下前提：<br>access_token有效且未超时；如果access_token失效，则通过refresh_token重新同步。若refresh_token也失效了则需要用户重新授权登录。</p><h3 id="Eg-通过UID获取用户基本信息"><a href="#Eg-通过UID获取用户基本信息" class="headerlink" title="Eg.通过UID获取用户基本信息"></a>Eg.通过UID获取用户基本信息</h3><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p><code>https://apihost/user?access_token=ak_1&amp;uid=10024</code></p><h3 id="正确的返回"><a href="#正确的返回" class="headerlink" title="正确的返回"></a>正确的返回</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"code"</span>:<span class="number">200</span>,   </span><br><span class="line">   <span class="attr">"msg"</span>:<span class="string">"ok"</span>,   </span><br><span class="line">   <span class="attr">"data"</span>:&#123;</span><br><span class="line">       <span class="attr">"username"</span>:<span class="string">"zhangsan"</span>,</span><br><span class="line">       <span class="attr">"age"</span>:<span class="number">28</span>,</span><br><span class="line">       <span class="attr">"address"</span>:<span class="string">"xx路xx号"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误返回样例：-2"><a href="#错误返回样例：-2" class="headerlink" title="错误返回样例："></a>错误返回样例：</h3><p><code>{&quot;code&quot;:400,&quot;msg&quot;:&quot;invalid access_token&quot;}</code></p><h2 id="注意事项RISK-CONTROL"><a href="#注意事项RISK-CONTROL" class="headerlink" title="注意事项RISK CONTROL"></a>注意事项RISK CONTROL</h2><ol><li>access_token 为用户授权客户端发起接口调用的凭证（相当于用户登录态），存储在客户端，可能出现恶意获取access_token 后导致的用户数据泄漏、用户微信相关接口功能被恶意发起等行为；</li><li>refresh_token 为用户授权客户端应用的长效凭证，仅用于刷新access_token，但泄漏后相当于access_token 泄漏，风险同上。</li><li>单点/多点登录。介于我们当前的设计不考虑单点登录的问题，也就是说同一个账号在不同的客户端都可以同时登录，并且生成不同的token以供使用每个客户端程序维护自己的一套token即可。倘若要实现单点登录则在用户授权的时候做排重判断，如果已在其他重点登录则清空该重点的token，并且为当前链接生成新token对即可。具体情况shi</li><li>用户信息跟新，针对我们当前的授权方式一旦用户修改的密码，则要清空该用户所有终端的token，让其重新授权。这也是为什么要设计这套有状态的token机制主要原因</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;设计需求&quot;&gt;&lt;a href=&quot;#设计需求&quot; class=&quot;headerlink&quot; title=&quot;设计需求&quot;&gt;&lt;/a&gt;设计需求&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;统计在线列表，可以随时的踢下线，让客户端缓存的token失效&lt;/li&gt;
&lt;li&gt;30天内无需重新登录，默认可无限期延续&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Token生成方案&quot;&gt;&lt;a href=&quot;#Token生成方案&quot; class=&quot;headerlink&quot; title=&quot;Token生成方案&quot;&gt;&lt;/a&gt;Token生成方案&lt;/h2&gt;
    
    </summary>
    
      <category term="算法" scheme="https://blog.fanfq.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://blog.fanfq.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="openapi" scheme="https://blog.fanfq.com/tags/openapi/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API Best Practices</title>
    <link href="https://blog.fanfq.com/api/RESTful_API_Best_Practices.html"/>
    <id>https://blog.fanfq.com/api/RESTful_API_Best_Practices.html</id>
    <published>2018-10-30T01:14:33.000Z</published>
    <updated>2018-11-13T10:14:21.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="URL-设计"><a href="#URL-设计" class="headerlink" title="URL 设计"></a>URL 设计</h2><h3 id="动词-宾语"><a href="#动词-宾语" class="headerlink" title="动词 + 宾语"></a>动词 + 宾语</h3><p>RESTful 的核心思想就是，客户端发出的数据操作指令都是”动词 + 宾语”的结构。比如，GET /articles这个命令，GET是动词，/articles是宾语。</p><p>动词通常就是五种 HTTP 方法，对应 CRUD 操作。</p><p>GET：读取（Read）<br>POST：新建（Create）<br>PUT：更新（Update）<br>PATCH：更新（Update），通常是部分更新<br>DELETE：删除（Delete）<br>根据 HTTP 规范，动词一律大写。</p><h3 id="动词的覆盖"><a href="#动词的覆盖" class="headerlink" title="动词的覆盖"></a>动词的覆盖</h3><p>有些客户端只能使用GET和POST这两种方法。服务器必须接受POST模拟其他三个方法（PUT、PATCH、DELETE）。</p><p>这时，客户端发出的 HTTP 请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /api/Person/4 HTTP/1.1  </span><br><span class="line">X-HTTP-Method-Override: PUT</span><br></pre></td></tr></table></figure><p>上面代码中，X-HTTP-Method-Override指定本次请求的方法是PUT，而不是POST。</p><h3 id="宾语必须是名词"><a href="#宾语必须是名词" class="headerlink" title="宾语必须是名词"></a>宾语必须是名词</h3><p>宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。比如，/articles这个 URL 就是正确的，而下面的 URL 不是名词，所以都是错误的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/getAllCars</span><br><span class="line">/createNewCar</span><br><span class="line">/deleteAllRedCars</span><br></pre></td></tr></table></figure></p><h3 id="复数-URL"><a href="#复数-URL" class="headerlink" title="复数 URL"></a>复数 URL</h3><p>既然 URL 是名词，那么应该使用复数，还是单数？</p><p>这没有统一的规定，但是常见的操作是读取一个集合，比如GET /articles（读取所有文章），这里明显应该是复数。</p><p>为了统一起见，建议都使用复数 URL，比如GET /articles/2要好于GET /article/2。</p><h3 id="避免多级-URL"><a href="#避免多级-URL" class="headerlink" title="避免多级 URL"></a>避免多级 URL</h3><p>常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /authors/12/categories/2</span><br></pre></td></tr></table></figure><p>这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。</p><p>更好的做法是，除了第一级，其他级别都用查询字符串表达。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /authors/12?categories=2</span><br></pre></td></tr></table></figure><p>下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /articles/published</span><br></pre></td></tr></table></figure><p>查询字符串的写法明显更好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /articles?published=true</span><br></pre></td></tr></table></figure><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><h3 id="状态码必须精确"><a href="#状态码必须精确" class="headerlink" title="状态码必须精确"></a>状态码必须精确</h3><p>客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。</p><p>HTTP 状态码就是一个三位数，分成五个类别。</p><p>1xx：相关信息<br>2xx：操作成功<br>3xx：重定向<br>4xx：客户端错误<br>5xx：服务器错误<br>这五大类总共包含100多种状态码，覆盖了绝大部分可能遇到的情况。每一种状态码都有标准的（或者约定的）解释，客户端只需查看状态码，就可以判断出发生了什么情况，所以服务器应该返回尽可能精确的状态码。</p><p>API 不需要1xx状态码，下面介绍其他四类状态码的精确含义。</p><h3 id="2xx-状态码"><a href="#2xx-状态码" class="headerlink" title="2xx 状态码"></a>2xx 状态码</h3><p>200状态码表示操作成功，但是不同的方法可以返回更精确的状态码。</p><p>GET: 200 OK<br>POST: 201 Created<br>PUT: 200 OK<br>PATCH: 200 OK<br>DELETE: 204 No Content<br>上面代码中，POST返回201状态码，表示生成了新的资源；DELETE返回204状态码，表示资源已经不存在。</p><p>此外，202 Accepted状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理，通常用于异步操作。下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 202 Accepted</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;task&quot;: &#123;</span><br><span class="line">    &quot;href&quot;: &quot;/api/company/job-management/jobs/2130040&quot;,</span><br><span class="line">    &quot;id&quot;: &quot;2130040&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3xx-状态码"><a href="#3xx-状态码" class="headerlink" title="3xx 状态码"></a>3xx 状态码</h3><p>API 用不到301状态码（永久重定向）和302状态码（暂时重定向，307也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。</p><p>API 用到的3xx状态码，主要是303 See Other，表示参考另一个 URL。它与302和307的含义一样，也是”暂时重定向”，区别在于302和307用于GET请求，而303用于POST、PUT和DELETE请求。收到303以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 303 See Other</span><br><span class="line">Location: /api/orders/12345</span><br></pre></td></tr></table></figure><h3 id="4xx-状态码"><a href="#4xx-状态码" class="headerlink" title="4xx 状态码"></a>4xx 状态码</h3><p>4xx状态码表示客户端错误，主要有下面几种。</p><p>400 Bad Request：服务器不理解客户端的请求，未做任何处理。</p><p>401 Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。</p><p>403 Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。</p><p>404 Not Found：所请求的资源不存在，或不可用。</p><p>405 Method Not Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。</p><p>410 Gone：所请求的资源已从这个地址转移，不再可用。</p><p>415 Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。</p><p>422 Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。</p><p>429 Too Many Requests：客户端的请求次数超过限额。</p><h3 id="5xx-状态码"><a href="#5xx-状态码" class="headerlink" title="5xx 状态码"></a>5xx 状态码</h3><p>5xx状态码表示服务端错误。一般来说，API 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。</p><p>500 Internal Server Error：客户端请求有效，服务器处理时发生了意外。</p><p>503 Service Unavailable：服务器无法处理请求，一般用于网站维护状态。</p><h2 id="服务器回应"><a href="#服务器回应" class="headerlink" title="服务器回应"></a>服务器回应</h2><h3 id="不要返回纯本文"><a href="#不要返回纯本文" class="headerlink" title="不要返回纯本文"></a>不要返回纯本文</h3><p>API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的Content-Type属性要设为application/json。</p><p>客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的ACCEPT属性也要设成application/json。下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /orders/2 HTTP/1.1 </span><br><span class="line">Accept: application/json</span><br></pre></td></tr></table></figure><h3 id="发生错误时，不要返回-200-状态码"><a href="#发生错误时，不要返回-200-状态码" class="headerlink" title="发生错误时，不要返回 200 状态码"></a>发生错误时，不要返回 200 状态码</h3><p>有一种不恰当的做法是，即使发生错误，也返回200状态码，把错误信息放在数据体里面，就像下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;failure&quot;,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;error&quot;: &quot;Expected at least two items in list.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中，解析数据体以后，才能得知操作失败。</p><p>这张做法实际上取消了状态码，这是完全不可取的。正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回。下面是一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &quot;Invalid payoad.&quot;,</span><br><span class="line">  &quot;detail&quot;: &#123;</span><br><span class="line">     &quot;surname&quot;: &quot;This field is required.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><span class="label danger">而我的做法是事先定义好返回数据的规范如下：</span></strong> </p><table><thead><tr><th>参数</th><th>定义</th><th>描述</th></tr></thead><tbody><tr><td>code</td><td>状态码</td><td>定义200为成功，其他均为失败。其具体缘由体现在msg内容</td></tr><tr><td>msg</td><td>返回信息</td><td>用户自定义的消息简述</td></tr><tr><td>data</td><td>返回对象</td><td>该字段承载着各种的数据，最终前端显示的数据都是从这个参数中获取</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">“code”:200,</span><br><span class="line">“msg”:”correct request”,</span><br><span class="line">“data”,null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 500 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">“code”:500,</span><br><span class="line">“msg”:”incorrect request”,</span><br><span class="line">“data”,null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提供链接"><a href="#提供链接" class="headerlink" title="提供链接"></a>提供链接</h3><p>API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS。</p><p>举例来说，GitHub 的 API 都在 api.github.com 这个域名。访问它，就可以得到其他 URL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;feeds_url&quot;: &quot;https://api.github.com/feeds&quot;,</span><br><span class="line">  &quot;followers_url&quot;: &quot;https://api.github.com/user/followers&quot;,</span><br><span class="line">  &quot;following_url&quot;: &quot;https://api.github.com/user/following&#123;/target&#125;&quot;,</span><br><span class="line">  &quot;gists_url&quot;: &quot;https://api.github.com/gists&#123;/gist_id&#125;&quot;,</span><br><span class="line">  &quot;hub_url&quot;: &quot;https://api.github.com/hub&quot;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的回应中，挑一个 URL 访问，又可以得到别的 URL。对于用户来说，不需要记住 URL 设计，只要从 api.github.com 一步步查找就可以了。</p><p>HATEOAS 的格式没有统一规定，上面例子中，GitHub 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;In progress&quot;,</span><br><span class="line">   &quot;links&quot;: &#123;[</span><br><span class="line">    &#123; &quot;rel&quot;:&quot;cancel&quot;, &quot;method&quot;: &quot;delete&quot;, &quot;href&quot;:&quot;/api/status/12345&quot; &#125; ,</span><br><span class="line">    &#123; &quot;rel&quot;:&quot;edit&quot;, &quot;method&quot;: &quot;put&quot;, &quot;href&quot;:&quot;/api/status/12345&quot; &#125;</span><br><span class="line">  ]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>RESTful API Design: 13 Best Practices to Make Your Users Happy, by Florimond Manca<br>API design, by MicroSoft Azure<br><a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="api" scheme="https://blog.fanfq.com/categories/api/"/>
    
    
      <category term="design" scheme="https://blog.fanfq.com/tags/design/"/>
    
      <category term="api" scheme="https://blog.fanfq.com/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>Internal APIs encrypt Method V1.0</title>
    <link href="https://blog.fanfq.com/InternalAPIs_encrypt_Method_V1.0.html"/>
    <id>https://blog.fanfq.com/InternalAPIs_encrypt_Method_V1.0.html</id>
    <published>2018-10-29T13:56:43.000Z</published>
    <updated>2018-11-07T01:11:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简单对称密码加密解密"><a href="#简单对称密码加密解密" class="headerlink" title="简单对称密码加密解密"></a>简单对称密码加密解密</h2><p>2018/10/19 我们发现大量的非法不带参数的Http请求访问我们的 apihost, 请求日志文件如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">183.223.44.221 - - [19/Oct/2018:16:47:32 +0800] &quot;POST /api_interface? HTTP/1.1&quot; 200 174 &quot;-&quot; &quot;okhttp/3.10.0&quot;</span><br><span class="line">请求者IP：183.223.44.221 </span><br><span class="line">请求接口：api_interface</span><br><span class="line">请求方式：POST</span><br><span class="line">请求者UA：okhttp/3.10.0</span><br></pre></td></tr></table></figure><p>问题引申：既然是非法请求，为什么黑客没有带参数的请求？<br>实际上这是一个很好的问题，如果接口没有做任何安全处理的话，黑客通过抓包很容易拿到请求参数规则，然后通过模拟请求达到目的。一旦接口做过”特殊工艺”处理了，黑客即将无处是从了。最终他们的心态都是从破解到放弃这样一个过程。</p><a id="more"></a><h2 id="正确的请求姿势："><a href="#正确的请求姿势：" class="headerlink" title="正确的请求姿势："></a>正确的请求姿势：</h2><p>实际上我们的设计接口的时候会有一个统一的接收参数 params 用来接收我们的数据，正确的请求如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">183.223.44.221 - - [19/Oct/2018:16:47:32 +0800] &quot;POST /api_interface?params=sM4AOVdWfPE4DxkXGEs8VFmEsZRgy58UYDPD7PjVYQXx1GEFrbjXMo11fb9x6ppwuaAeXV3n2DtoW4lG22nM0g HTTP/1.1&quot; 200 174 &quot;-&quot; &quot;okhttp/3.10.0&quot;</span><br><span class="line">请求者IP：183.223.44.221 </span><br><span class="line">请求接口：api_interface?params=sM4AOVdWfPE4DxkXGEs8VFmEsZRgy58UYDPD7PjVYQXx1GEFrbjXMo11fb9x6ppwuaAeXV3n2DtoW4lG22nM0g</span><br><span class="line">请求方式：POST</span><br><span class="line">请求者UA：okhttp/3.10.0</span><br></pre></td></tr></table></figure><h2 id="拓扑结构："><a href="#拓扑结构：" class="headerlink" title="拓扑结构："></a>拓扑结构：</h2><p>什么请求者IP,请求方式，UA都不是重点。重点在于我们的接口都会有一个params的参数，而这个参数的本身是通过加密算法形成的，即使黑客捕获到这串没有意义的密文也头疼。因为我们和客户端程序有规定所有请求的参数必须要用公钥加密后再通过特点的算法传递，同时服务器端返回的数据也是通过这套算法加密后传输。拓扑结构如下图。</p><img src="/uploads/WX20181029-223437@2x.png"><h2 id="为什么要数据加密？"><a href="#为什么要数据加密？" class="headerlink" title="为什么要数据加密？"></a>为什么要数据加密？</h2><p>安全，安全，安全。</p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>现在通过一个示例完整的描述一下我们的接口设计中加密解密过程。</p><p><strong>公钥</strong><br>上文中说道，我们同时约定了一套公钥给服务器端与客户端，为了配合下面的算法使用所以我们采用Int 类型的数字。现在定义为 KEY = 110; 为了确保安全性这个KEY只有内部知道。</p><p><strong>算法</strong></p><ul><li>XOR （with KEY）</li><li>BASE64 (encode/decode)</li><li>URLEncode/URLDecode</li></ul><h2 id="Eg-客户端-zhangsan-执行登录请求"><a href="#Eg-客户端-zhangsan-执行登录请求" class="headerlink" title="Eg.客户端 zhangsan 执行登录请求"></a>Eg.客户端 zhangsan 执行登录请求</h2><p><strong>将要发送的数据:</strong><br><code>{username:zhangsan,password:123456,action:login}</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; reqMap = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"><span class="keyword">int</span> key = <span class="number">110</span>;<span class="comment">//客户端与服务器端共同约定的公钥</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">be</span><span class="params">()</span> </span>&#123;</span><br><span class="line">reqMap.put(<span class="string">"username"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line">reqMap.put(<span class="string">"password"</span>, <span class="string">"123456"</span>);</span><br><span class="line">reqMap.put(<span class="string">"action"</span>, <span class="string">"login"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加密算法 （java实现）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.xor</span></span><br><span class="line"><span class="keyword">byte</span>[] byteArry = reqMap.toString().getBytes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; byteArry.length; i++) &#123;</span><br><span class="line">    byteArry[i] = (<span class="keyword">byte</span>) (byteArry[i] ^ key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.base64.ecode</span></span><br><span class="line">String encode = <span class="keyword">new</span> BASE64Encoder().encode(byteArry);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.url.encode</span></span><br><span class="line">String dist = URLEncoder.encode(encode, <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"params="</span>+dist);</span><br></pre></td></tr></table></figure></p><p>输出的params为:<br><code>params=FR4PHR0ZARwKU19cXVpbWEJODw0aBwEAUwIBCQcAQk4bHQscAA8DC1MUBg8ACR0PABM%3D</code></p><p><strong>解密算法 （java实现）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String params = <span class="string">"FR4PHR0ZARwKU19cXVpbWEJODw0aBwEAUwIBCQcAQk4bHQscAA8DC1MUBg8ACR0PABM%3D"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.url.decode</span></span><br><span class="line">String decode = URLDecoder.decode(params, <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.base64.decode</span></span><br><span class="line"><span class="keyword">byte</span>[] byteArry = <span class="keyword">new</span> BASE64Decoder().decodeBuffer(decode);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.xor</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; byteArry.length; i++) &#123;</span><br><span class="line">    byteArry[i] = (<span class="keyword">byte</span>) (byteArry[i] ^ key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"dist:"</span>+<span class="keyword">new</span> String(byteArry));</span><br></pre></td></tr></table></figure></p><p>输出的dist为：<br><code>dist={username:zhangsan,password:123456,action:login}</code></p><h2 id="对称加密优缺点"><a href="#对称加密优缺点" class="headerlink" title="对称加密优缺点"></a>对称加密优缺点</h2><p>对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。适用于简单的报文加密，同时也使用用大报文加密。<br>对称加密算法的缺点是在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。</p><h2 id="常用的对称密钥算法"><a href="#常用的对称密钥算法" class="headerlink" title="常用的对称密钥算法"></a>常用的对称密钥算法</h2><p>加密和解密都使用同一把秘钥，这种加密方法称为对称加密，也称为单密钥加密。<br>简单理解为：加密解密都是同一把钥匙。<br>AES、DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK 等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单对称密码加密解密&quot;&gt;&lt;a href=&quot;#简单对称密码加密解密&quot; class=&quot;headerlink&quot; title=&quot;简单对称密码加密解密&quot;&gt;&lt;/a&gt;简单对称密码加密解密&lt;/h2&gt;&lt;p&gt;2018/10/19 我们发现大量的非法不带参数的Http请求访问我们的 apihost, 请求日志文件如下所示。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;183.223.44.221 - - [19/Oct/2018:16:47:32 +0800] &amp;quot;POST /api_interface? HTTP/1.1&amp;quot; 200 174 &amp;quot;-&amp;quot; &amp;quot;okhttp/3.10.0&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;请求者IP：183.223.44.221 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;请求接口：api_interface&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;请求方式：POST&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;请求者UA：okhttp/3.10.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;问题引申：既然是非法请求，为什么黑客没有带参数的请求？&lt;br&gt;实际上这是一个很好的问题，如果接口没有做任何安全处理的话，黑客通过抓包很容易拿到请求参数规则，然后通过模拟请求达到目的。一旦接口做过”特殊工艺”处理了，黑客即将无处是从了。最终他们的心态都是从破解到放弃这样一个过程。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://blog.fanfq.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://blog.fanfq.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="openapi" scheme="https://blog.fanfq.com/tags/openapi/"/>
    
  </entry>
  
  <entry>
    <title>Open APIs encrypt Method V1.1</title>
    <link href="https://blog.fanfq.com/%E7%AE%97%E6%B3%95/OpenAPIs_encrypt_Method_V1.1.html"/>
    <id>https://blog.fanfq.com/算法/OpenAPIs_encrypt_Method_V1.1.html</id>
    <published>2018-10-29T06:57:41.000Z</published>
    <updated>2018-11-06T14:17:45.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="非对称密码加密解密-amp-签名机制-amp-重放攻击"><a href="#非对称密码加密解密-amp-签名机制-amp-重放攻击" class="headerlink" title="非对称密码加密解密&amp;签名机制&amp;重放攻击"></a>非对称密码加密解密&amp;签名机制&amp;重放攻击</h2><p>《Internal APIs encrypt Method V1.0》 文章中已经描述了我们正在线上产品所用的加密算法，实际上他不仅仅是解决防参数篡改的问题，同时也解决了数据隐私保护的问题。即便如此这套算法还是有漏洞的，也是做所以定义为 Internal APIs的主要原因了，由于只提供给内部使用所以安全性暂且得到保障，一旦提供给外部使用则全盘”露馅”了,这也是我为什么要编辑此篇《Open APIs encrypt Method V1.1》文章了。</p><p>其中最为致命的问题是要在客户端代码中公开自己的密钥以及算法，一旦黑客从客户端程序中反编译源码，这样就会导致整个加密体系的崩盘，而且连补救的措施都没有。</p><p>同时第二个比较严重的问题就是黑客从放攻击的问题，黑客在抓取到包体后，直接再次提交请求导致服务器端不断受到重复请求。</p><p>所以基于以上两点，我们了解到《Internal APIs encrypt Method V1.0》所存在的问题如下表所示</p><a id="more"></a><table><thead><tr><th>问题描述</th><th>安全性</th><th>解决方案</th></tr></thead><tbody><tr><td>脱敏（数据隐私保护）</td><td>安全</td><td></td></tr><tr><td>完整性 （防参数篡改）</td><td>安全</td><td></td></tr><tr><td>重放攻击 （重复提交）</td><td>未解决</td><td>timestamp + nonce</td></tr><tr><td>对称密钥</td><td>不够安全</td><td>非对称密钥</td></tr></tbody></table><h2 id="签名机制："><a href="#签名机制：" class="headerlink" title="签名机制："></a>签名机制：</h2><p>所以本文重点就是要解决 重放攻击 (重复提交) &amp; 密钥安全 这两个问题。在此之前再介绍一种常用的解决数据传输过程中确保完整性 （防参数篡改）的解决方案，过程如下：</p><ol><li>客户端使用约定好的秘钥对传输参数进行加密，得到签名值signature，并且将签名值也放入请求参数中，发送请求给服务端</li><li>服务端接收客户端的请求，然后使用约定好的秘钥对请求的参数（除了signature以外）再次进行签名，得到签名值autograph。</li><li>服务端对比signature和autograph的值，如果对比一致，认定为合法请求。如果对比不一致，说明参数被篡改，认定为非法请求。</li></ol><h3 id="Eg-客户端-zhangsan-执行登录请求"><a href="#Eg-客户端-zhangsan-执行登录请求" class="headerlink" title="Eg.客户端 zhangsan 执行登录请求"></a>Eg.客户端 zhangsan 执行登录请求</h3><p>将要发送的数据：<br><code>apihost?action=login&amp;username=zhangsan&amp;password=123456&amp;sign=</code></p><h3 id="签名算法：-java-实现"><a href="#签名算法：-java-实现" class="headerlink" title="签名算法：(java 实现)"></a>签名算法：(java 实现)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.对除sign外的所有参数按字典排序 对所有待签名参数按照字段名的 ASCII码从小到大排序（字典序）后</span></span><br><span class="line">String[] arr =  <span class="keyword">new</span> String[] &#123; <span class="string">"username=zhangsan"</span>,<span class="string">"password=123456"</span>, <span class="string">"action=login"</span>&#125;;</span><br><span class="line">Arrays.sort(arr); </span><br><span class="line"></span><br><span class="line"><span class="comment">//2.将排序后的结果拼接成一个字符串（即key1=value1&amp;key2=value2…）</span></span><br><span class="line">String content = arr[<span class="number">0</span>].concat(<span class="string">"&amp;"</span>+arr[<span class="number">1</span>]).concat(<span class="string">"&amp;"</span>+arr[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、将字符串进行sha1加密得到sign值</span></span><br><span class="line">MessageDigest md = <span class="keyword">null</span>;</span><br><span class="line">String sign = <span class="keyword">null</span>;  </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    md = MessageDigest.getInstance(<span class="string">"SHA-1"</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] digest = md.digest(content.toString().getBytes());</span><br><span class="line">    sign = StrUtil.byteToStr(digest);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"sign="</span>+sign);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出的sign为:<br><code>sign=ebb36366bd9d8656e2327ca913a4f854f35a0e95</code></p><h3 id="最终请求服务器的数据为："><a href="#最终请求服务器的数据为：" class="headerlink" title="最终请求服务器的数据为："></a>最终请求服务器的数据为：</h3><p><code>apihost?action=login&amp;username=zhangsan&amp;password=123456&amp;sign=ebb36366bd9d8656e2327ca913a4f854f35a0e95</code></p><p>当服务器拿到数据后再进行同样的算法然后再匹配sign值是否一致，如果对比一致，认定为合法请求。如果对比不一致，说明参数被篡改，认定为非法请求。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ol><li>参数排序很重要，不同的排序会导致签名值不一致。所以要事先规定好排序算法。</li><li>sign算法也要事先规定好，示例中是一个简单的算法并没有使用到密钥。实际过程中可能更加复杂签名的秘钥我们可以使用很多方案，可以采用对称加密或者非对称加密。</li><li>因为黑客不知道签名的秘钥，也不知道签名的算法，所以即使截取到请求数据，对请求参数进行篡改，但是却无法对参数进行签名，无法得到修改后参数的签名值signature。</li><li>示例中并没有解决数据脱敏的问题，应用过程中可以根据实际情况再进行脱敏算法。</li></ol><h2 id="防止重放攻击"><a href="#防止重放攻击" class="headerlink" title="防止重放攻击"></a>防止重放攻击</h2><h3 id="基于timestamp的方案"><a href="#基于timestamp的方案" class="headerlink" title="基于timestamp的方案"></a>基于timestamp的方案</h3><p>每次HTTP请求，都需要加上timestamp参数，然后把timestamp和其他参数一起进行数字签名。因为一次正常的HTTP请求，从发出到达服务器一般都不会超过60s，所以服务器收到HTTP请求之后，首先判断时间戳参数与当前时间相比较，是否超过了60s，如果超过了则认为是非法的请求。</p><p>一般情况下，黑客从抓包重放请求耗时远远超过了60s，所以此时请求中的timestamp参数已经失效了。</p><p>如果黑客修改timestamp参数为当前的时间戳，则signature参数对应的数字签名就会失效，因为黑客不知道签名秘钥，没有办法生成新的数字签名。</p><p>但这种方式的漏洞也是显而易见的，如果在60s之后进行重放攻击，那就没办法了，所以这种方式不能保证请求仅一次有效。</p><h3 id="基于nonce的方案"><a href="#基于nonce的方案" class="headerlink" title="基于nonce的方案"></a>基于nonce的方案</h3><p>nonce的意思是仅一次有效的随机字符串，要求每次请求时，该参数要保证不同，所以该参数一般与时间戳有关，我们这里为了方便起见，直接使用时间戳的16进制，实际使用时可以加上客户端的ip地址，mac地址等信息做个哈希之后，作为nonce参数。</p><p>我们将每次请求的nonce参数存储到一个“集合”中，可以json格式存储到数据库或缓存中。</p><p>每次处理HTTP请求时，首先判断该请求的nonce参数是否在该“集合”中，如果存在则认为是非法请求。</p><p>nonce参数在首次请求时，已经被存储到了服务器上的“集合”中，再次发送请求会被识别并拒绝。</p><p>nonce参数作为数字签名的一部分，是无法篡改的，因为黑客不清楚token，所以不能生成新的sign。</p><p>这种方式也有很大的问题，那就是存储nonce参数的“集合”会越来越大，验证nonce是否存在“集合”中的耗时会越来越长。我们不能让nonce“集合”无限大，所以需要定期清理该“集合”，但是一旦该“集合”被清理，我们就无法验证被清理了的nonce参数了。也就是说，假设该“集合”平均1天清理一次的话，我们抓取到的该url，虽然当时无法进行重放攻击，但是我们还是可以每隔一天进行一次重放攻击的。而且存储24小时内，所有请求的“nonce”参数，也是一笔不小的开销。</p><h3 id="基于timestamp和nonce的方案"><a href="#基于timestamp和nonce的方案" class="headerlink" title="基于timestamp和nonce的方案"></a>基于timestamp和nonce的方案</h3><p>nonce的一次性可以解决timestamp参数60s的问题，timestamp可以解决nonce参数“集合”越来越大的问题。<br>防止重放攻击一般和防止请求参数被串改一起做，请求的Headers数据如下图所示。</p><p>我们在timestamp方案的基础上，加上nonce参数，因为timstamp参数对于超过60s的请求，都认为非法请求，所以我们只需要存储60s的nonce参数的“集合”即可。</p><h4 id="HTTP请求头，参数说明："><a href="#HTTP请求头，参数说明：" class="headerlink" title="HTTP请求头，参数说明："></a>HTTP请求头，参数说明：</h4><p>由于每次数据请求都要带上这几个参数，所以直接将这几个参数设置在请求头中，从而简化body长度；当然也可以在去请求参数中拼凑视具体情况而定。</p><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>token</td><td>用户令牌，用于认证用户身份</td><td>稍微长一点的文本</td></tr><tr><td>sign</td><td>签名，用于监测请求数据的完整性</td><td>中等文本</td></tr><tr><td>timestamp</td><td>请求时间戳</td><td>根据的约定的保留毫秒或者精度到秒</td></tr><tr><td>nonce</td><td>请求随机字符串: MD5(时间戳+随机字符)</td><td>单位时间内产生不重复字符就好</td></tr></tbody></table><p>有关token的详细说明，请查看《Access Token &amp; Refresh Token 机制》这篇文章</p><h4 id="服务器端校验："><a href="#服务器端校验：" class="headerlink" title="服务器端校验："></a>服务器端校验：</h4><p>服务器端的校验配置通常会放在Filter / Interceptor 中,作为全局的管理。<br>nonce参数通常会存在redis中，并且设置TTL过期时间。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">String token = request.getHeader(<span class="string">"token"</span>);</span><br><span class="line">String timestamp = request.getHeader(<span class="string">"timestamp"</span>);</span><br><span class="line">String nonce = request.getHeader(<span class="string">"nonce"</span>);</span><br><span class="line">String sign = request.getHeader(<span class="string">"sign"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间限制配置 s</span></span><br><span class="line"><span class="keyword">int</span> timeLimit = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求头参数非空验证</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(token) || StringUtils.isEmpty(timestamp) || StringUtils.isEmpty(nonce) || StringUtils.isEmpty(sign)) &#123;</span><br><span class="line">    ctx.setResponseBody(JSON.toJSONString(<span class="keyword">new</span> Result(<span class="string">"-1"</span>, <span class="string">"请求头参数不正确"</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求时间和现在时间对比验证，发起请求时间和服务器时间不能超过timeLimit秒</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.timeDiffSeconds(<span class="keyword">new</span> Date(), timestamp) &gt; timeLimit) &#123;</span><br><span class="line">    ctx.setResponseBody(JSON.toJSONString(<span class="keyword">new</span> Result(<span class="string">"-1"</span>, <span class="string">"请求发起时间超过服务器限制"</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证用户信息</span></span><br><span class="line">UserInfo userInfo = UserInfoUtil.getInfoByToken(token);</span><br><span class="line"><span class="keyword">if</span> (userInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ctx.setResponseBody(JSON.toJSONString(<span class="keyword">new</span> Result(<span class="string">"-1"</span>, <span class="string">"错误的token信息"</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证相同noce的请求是否已经存在，存在表示为重复请求</span></span><br><span class="line"><span class="keyword">if</span> (NoceUtil.exsit(userInfo, nonce)) &#123;</span><br><span class="line">    ctx.setResponseBody(JSON.toJSONString(<span class="keyword">new</span> Result(<span class="string">"-1"</span>, <span class="string">"重复的请求"</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果noce没有在缓存中，则需要加入，并设置过期时间为timeLimit秒</span></span><br><span class="line">    NoceUtil.addNoce(userInfo, nonce, timeLimit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器生成签名与header中签名对比</span></span><br><span class="line">String serverSign = SignUtil.getSign(userinfo, token, timestamp, nonce, request);</span><br><span class="line"><span class="keyword">if</span> (!serverSign.equals(sign)) &#123;</span><br><span class="line">    ctx.setResponseBody(JSON.toJSONString(<span class="keyword">new</span> Result(<span class="string">"-1"</span>, <span class="string">"错误的签名信息"</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="非对称密钥"><a href="#非对称密钥" class="headerlink" title="非对称密钥"></a>非对称密钥</h2><h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><p>与对称密钥不同，非对称密钥要有一组密钥分别是公钥和私钥，通常情况下公钥加密，私钥解密。公钥可以发布给任意的客户端程序，服务器端则通过私钥解密。以下是非对称密钥的拓扑结构。</p><img src="/uploads/WX20181029-223454@2x.png"><p>如上图所以，发送者用接收方公开出来的公钥PK进行加密。接受方在收到密文后，再用与公钥对应的私钥SK进行解密。同样，密文即便被截获，但是由于截获者只有公钥，没有私钥，他不能进行解密</p><h3 id="非对称加密优缺点"><a href="#非对称加密优缺点" class="headerlink" title="非对称加密优缺点"></a>非对称加密优缺点</h3><p>非对称加密的突出优点是用于解密的密钥（也就是私钥）永远不需要传递给对方。但是，它的缺点也很突出：非对称加密算法复杂，导致加解密速度慢，故只适合小量数据的场合。而对称加密加解密效率高，系统开销小，适合进行大数据量的加解密。由于文件一般比较大，这个特性决定了适合它的加密方式最好是对称加密。</p><h3 id="Eg-RSA对称密钥算法（java实现）"><a href="#Eg-RSA对称密钥算法（java实现）" class="headerlink" title="Eg.RSA对称密钥算法（java实现）"></a>Eg.RSA对称密钥算法（java实现）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.fanfq.util.commons.encrypt.rsa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">    &lt;groupId&gt;commons-codec&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">    &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">    &lt;version&gt;1.11&lt;/version&gt;</span></span><br><span class="line"><span class="comment">&lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">https://www.jianshu.com/p/ff8281f034f4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fred</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSAUtil2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_ALGORITHM = <span class="string">"RSA"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SIGNATURE_ALGORITHM = <span class="string">"MD5withRSA"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PUBLIC_KEY = <span class="string">"RSAPublicKey"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRIVATE_KEY = <span class="string">"RSAPrivateKey"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptBASE64(String key) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.decodeBase64(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encryptBASE64</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用私钥对信息生成数字签名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data       加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sign</span><span class="params">(String data, String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 解密由base64编码的私钥</span></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = decryptBASE64(privateKey);</span><br><span class="line">        <span class="comment">// 构造PKCS8EncodedKeySpec对象</span></span><br><span class="line">        PKCS8EncodedKeySpec pkcs8KeySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line">        <span class="comment">// KEY_ALGORITHM 指定的加密算法</span></span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="comment">// 取私钥匙对象</span></span><br><span class="line">        PrivateKey priKey = keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        <span class="comment">// 用私钥对信息生成数字签名</span></span><br><span class="line">        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">        signature.initSign(priKey);</span><br><span class="line">        signature.update(data.getBytes());</span><br><span class="line">        <span class="keyword">return</span> encryptBASE64(signature.sign());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验数字签名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sign      数字签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 校验成功返回true 失败返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String data, String publicKey, String sign)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 解密由base64编码的公钥</span></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = decryptBASE64(publicKey);</span><br><span class="line">        <span class="comment">// 构造X509EncodedKeySpec对象</span></span><br><span class="line">        X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line">        <span class="comment">// KEY_ALGORITHM 指定的加密算法</span></span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="comment">// 取公钥匙对象</span></span><br><span class="line">        PublicKey pubKey = keyFactory.generatePublic(keySpec);</span><br><span class="line">        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">        signature.initVerify(pubKey);</span><br><span class="line">        signature.update(data.getBytes());</span><br><span class="line">        <span class="comment">// 验证签名是否正常</span></span><br><span class="line">        <span class="keyword">return</span> signature.verify(decryptBASE64(sign));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptByPrivateKey(<span class="keyword">byte</span>[] data, String key) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 对密钥解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得私钥</span></span><br><span class="line">        PKCS8EncodedKeySpec pkcs8KeySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        Key privateKey = keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        <span class="comment">// 对数据解密</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 用私钥解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptByPrivateKey(String data, String key)</span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> decryptByPrivateKey(decryptBASE64(data),key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 用公钥解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decryptByPublicKey</span><span class="params">(String data, String key)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] datas = decryptBASE64(data);</span><br><span class="line">        <span class="comment">// 对密钥解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得公钥</span></span><br><span class="line">        X509EncodedKeySpec x509KeySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        Key publicKey = keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">        <span class="comment">// 对数据解密</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(cipher.doFinal(datas));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 用公钥加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encryptByPublicKey</span><span class="params">(String data, String key)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 对公钥解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得公钥</span></span><br><span class="line">        X509EncodedKeySpec x509KeySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        Key publicKey = keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">        <span class="comment">// 对数据加密</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">return</span> encryptBASE64(cipher.doFinal(data.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 用私钥加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encryptByPrivateKey</span><span class="params">(String data, String key)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 对密钥解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得私钥</span></span><br><span class="line">        PKCS8EncodedKeySpec pkcs8KeySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        Key privateKey = keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        <span class="comment">// 对数据加密</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">return</span> encryptBASE64(cipher.doFinal(data.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得私钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPrivateKey</span><span class="params">(Map&lt;String, Key&gt; keyMap)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Key key = (Key) keyMap.get(PRIVATE_KEY);</span><br><span class="line">        <span class="keyword">return</span> encryptBASE64(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得公钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPublicKey</span><span class="params">(Map&lt;String, Key&gt; keyMap)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Key key = keyMap.get(PUBLIC_KEY);</span><br><span class="line">        <span class="keyword">return</span> encryptBASE64(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化密钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Key&gt; <span class="title">initKey</span><span class="params">(<span class="keyword">int</span> length)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyPairGenerator keyPairGen = KeyPairGenerator</span><br><span class="line">                .getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="keyword">if</span>(length != <span class="number">2048</span>) length = <span class="number">1024</span>;</span><br><span class="line">        keyPairGen.initialize(length);</span><br><span class="line">        KeyPair keyPair = keyPairGen.generateKeyPair();</span><br><span class="line">        Map&lt;String, Key&gt; keyMap = <span class="keyword">new</span> HashMap(<span class="number">2</span>);</span><br><span class="line">        keyMap.put(PUBLIC_KEY, keyPair.getPublic());<span class="comment">// 公钥</span></span><br><span class="line">        keyMap.put(PRIVATE_KEY, keyPair.getPrivate());<span class="comment">// 私钥</span></span><br><span class="line">        <span class="keyword">return</span> keyMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanfq.util.commons.encrypt.rsa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.security.Key;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSAUtil2Test</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String publicKey;</span><br><span class="line">    <span class="keyword">private</span> String privateKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;String, Key&gt; keyMap = RSAUtil2.initKey(<span class="number">2048</span>);</span><br><span class="line">        publicKey = RSAUtil2.getPublicKey(keyMap);</span><br><span class="line">        privateKey = RSAUtil2.getPrivateKey(keyMap);</span><br><span class="line">        System.out.println(<span class="string">"公钥:"</span> + publicKey.length());</span><br><span class="line">        System.out.println(publicKey);</span><br><span class="line">        System.out.println(<span class="string">"私钥:"</span> + privateKey.length());</span><br><span class="line">        System.out.println(privateKey);</span><br><span class="line">        </span><br><span class="line">        ObjectOutputStream oos1 = <span class="keyword">null</span>;  </span><br><span class="line">        ObjectOutputStream oos2 = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">/** 用对象流将生成的密钥写入文件 */</span>  </span><br><span class="line">            oos1 = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"RSA_PUBLIC_KEY"</span>));  </span><br><span class="line">            oos2 = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"RSA_PRIVATE_KEY"</span>));  </span><br><span class="line">            oos1.writeObject(publicKey);  </span><br><span class="line">            oos2.writeObject(privateKey);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> e;  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            <span class="comment">/** 清空缓存，关闭文件输出流 */</span>  </span><br><span class="line">            oos1.close();  </span><br><span class="line">            oos2.close();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"\n-------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"公钥加密——私钥解密"</span>);</span><br><span class="line">        String inputStr = <span class="string">"dounine"</span>;</span><br><span class="line">        String encodedData = RSAUtil2.encryptByPublicKey(inputStr, publicKey);</span><br><span class="line">        <span class="keyword">byte</span>[] decodedData = RSAUtil2.decryptByPrivateKey(encodedData,</span><br><span class="line">                privateKey);</span><br><span class="line">        String outputStr = <span class="keyword">new</span> String(decodedData);</span><br><span class="line">        System.out.println(<span class="string">"加密前: "</span> + inputStr);</span><br><span class="line">        System.out.println(<span class="string">"公钥加密后: "</span> + encodedData);</span><br><span class="line">        System.out.println(<span class="string">"私钥解密后: "</span> + outputStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSign</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"\n-------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"私钥加密——公钥解密"</span>);</span><br><span class="line">        String inputStr = <span class="string">"dounine"</span>;</span><br><span class="line">        String encodedData = RSAUtil2.encryptByPrivateKey(inputStr, privateKey);</span><br><span class="line">        String decodedData = RSAUtil2.decryptByPublicKey(encodedData, publicKey);</span><br><span class="line">        System.out.println(<span class="string">"加密前: "</span> + inputStr);</span><br><span class="line">        System.out.println(<span class="string">"私钥加密后: "</span> + encodedData);</span><br><span class="line">        System.out.println(<span class="string">"公钥解密后: "</span> + decodedData);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"\n私钥签名——公钥验证签名"</span>);</span><br><span class="line">        <span class="comment">// 产生签名</span></span><br><span class="line">        String sign = RSAUtil2.sign(<span class="string">"123"</span>, privateKey);</span><br><span class="line">        System.out.println(<span class="string">"私钥签名:("</span>+sign.length()+<span class="string">")"</span> + sign);</span><br><span class="line">        <span class="comment">// 验证签名</span></span><br><span class="line">        <span class="keyword">boolean</span> status = RSAUtil2.verify(encodedData, publicKey, sign);</span><br><span class="line">        System.out.println(<span class="string">"公钥验证签名:"</span> + status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    RSAUtil2Test rsa = <span class="keyword">new</span> RSAUtil2Test();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      rsa.setUp();</span><br><span class="line">      rsa.test();</span><br><span class="line">      rsa.testSign();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;非对称密码加密解密-amp-签名机制-amp-重放攻击&quot;&gt;&lt;a href=&quot;#非对称密码加密解密-amp-签名机制-amp-重放攻击&quot; class=&quot;headerlink&quot; title=&quot;非对称密码加密解密&amp;amp;签名机制&amp;amp;重放攻击&quot;&gt;&lt;/a&gt;非对称密码加密解密&amp;amp;签名机制&amp;amp;重放攻击&lt;/h2&gt;&lt;p&gt;《Internal APIs encrypt Method V1.0》 文章中已经描述了我们正在线上产品所用的加密算法，实际上他不仅仅是解决防参数篡改的问题，同时也解决了数据隐私保护的问题。即便如此这套算法还是有漏洞的，也是做所以定义为 Internal APIs的主要原因了，由于只提供给内部使用所以安全性暂且得到保障，一旦提供给外部使用则全盘”露馅”了,这也是我为什么要编辑此篇《Open APIs encrypt Method V1.1》文章了。&lt;/p&gt;
&lt;p&gt;其中最为致命的问题是要在客户端代码中公开自己的密钥以及算法，一旦黑客从客户端程序中反编译源码，这样就会导致整个加密体系的崩盘，而且连补救的措施都没有。&lt;/p&gt;
&lt;p&gt;同时第二个比较严重的问题就是黑客从放攻击的问题，黑客在抓取到包体后，直接再次提交请求导致服务器端不断受到重复请求。&lt;/p&gt;
&lt;p&gt;所以基于以上两点，我们了解到《Internal APIs encrypt Method V1.0》所存在的问题如下表所示&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://blog.fanfq.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://blog.fanfq.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="openapi" scheme="https://blog.fanfq.com/tags/openapi/"/>
    
  </entry>
  
</feed>
